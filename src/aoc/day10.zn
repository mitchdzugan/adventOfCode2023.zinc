(require '["/aoc/lib.zn" :as lib])
(require '["/+.zn" :as + :refer-macros true])

(def+ DirT (Up) (Down) (Left) (Right))
(def Left  (mk (Left  of DirT)))
(def Right (mk (Right of DirT)))
(def Up    (mk (Up    of DirT)))
(def Down  (mk (Down  of DirT)))

(defn next-dir [c dir]
  (cond
    (+/is c "-") (impl [DirT dir] (Left  Left ) (Right Right))
    (+/is c "7") (impl [DirT dir] (Up    Left ) (Right Down ))
    (+/is c "|") (impl [DirT dir] (Up    Up   ) (Down  Down ))
    (+/is c "J") (impl [DirT dir] (Down  Left ) (Right Up   ))
    (+/is c "L") (impl [DirT dir] (Down  Right) (Left  Up   ))
    (+/is c "F") (impl [DirT dir] (Up    Right) (Left  Down ))))

(def* PosT [x y])
(defn-mk (Pos [x y] PosT) (%= [x y]))

(defn eq-pos [p1 p2]
  (un [PosT p1 :prefix {:type :ns :s "p1"}]
    (un [PosT p2 :prefix {:type :ns :s "p2"}]
      (and (= %p1/x %p2/x) (= %p1/y %p2/y)))))

(defn-un get-at-pos [m PosT s-char]
  (let [res (+/or "." (+/at (+/or (+/Vec) (+/at m %y)) %x))]
    (if (+/is res "S") s-char res)))

(defn-un set-at-pos [m PosT v] (+/put (+/at! m %y) %x v))

(defn-un step-pos [PosT dir]
  (let [x %x y %y]
    (impl [DirT dir]
      (Left  (Pos (- x 1) y))
      (Right (Pos (+ x 1) y))
      (Up    (Pos x (- y 1)))
      (Down  (Pos x (+ y 1))))))

(def* InstT [m pos dir origin s-char])
(defn-mk (Inst [m pos dir origin s-char] InstT) (%= [m pos dir origin s-char]))
(defn-un inst-pos [InstT] %pos)

(defn-un step [InstT]
  (let [ndir (next-dir (get-at-pos %m %pos %s-char) %dir)]
    (Inst %m (step-pos %pos ndir) ndir %origin %s-char)))

(defn-un start? [InstT] (eq-pos %pos %origin))

(defn-memo loop-only-parse-input [input]
  (let [base (+/fmap #(lib/strsplit %1 "") (lib/strsplit input "\n"))
        loop-only (+/fmap #(+/fmap (fn [] ".") %1) base)
        ;; determined using the inspectGrid util fn ;;
        s-char "7"
        init-pos (Pos 74 82)
        init-dir Up
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        mk-inst #(Inst %1 init-pos init-dir init-pos s-char)]
    (loop [inst (step (mk-inst base))]
      (let [p (inst-pos inst)]
        (set-at-pos loop-only p (get-at-pos base p s-char)))
      (when-not (start? inst) (recur (step inst))))
    loop-only))

(defn part1 [input]
  (let [m (loop-only-parse-input input)]
    (->> (+/bind +/id m)
         (+/remove #(+/is "." %1))
         ((fn [p] (+/floor (/ (+/size p) 2)))))))

(defn-memo crossings-to-top-edge [m x y]
  (let [getc #(get-at-pos m (Pos x %1))
        plain? #(+/is (getc %1) ".")
        edge? #(or (+/is (getc %1) "-") (+/is (getc %1) "|"))
        corner? #(and (not (edge? %1)) (not (plain? (getc %1))))
        get-rest #(crossings-to-top-edge m x (- %1 1))]
    (cond
      (< y 0)     0
      (plain? y)  (get-rest y)
      (edge? y)   (+ 1 (get-rest y))
      :else
      (loop [suby (- y 1)]
        (if (edge? suby)
          (recur (- suby 1))
          (+ (get-rest suby)
             (if (= (next-dir (getc y   ) Down)
                    (next-dir (getc suby) Up  ))
               0 1)))))))

(defn-un enclosed? [m PosT]
  (and (= "." (get-at-pos m %.))
       (= 1 (+/mod (crossings-to-top-edge m %x %y) 2))))

(defn part2 [input]
  (let [m (loop-only-parse-input input)
        rincluded (aref 0)
        h (+/size m)
        w (+/size (+/at! m 0))]
    (->> (fn [row y] (+/size (+/filter #(enclosed? m (Pos %2 y)) row)))
         ((fn [mapper] (+/fmap mapper m)))
         (+/reduce #(+ %1 %2) 0))))

(defn inspectGrid [input]
  (let [m (+/fmap #(lib/strsplit %1 "") (lib/strsplit input "\n"))]
    (loop [i 0]
      (when (< i (+/size m))
        (loop [j 0]
          (when (< j (+/size (+/at! m i)))
            (if (+/is "S" (+/at! (+/at! m i) j))
              (do
                (+/log "I" i "J" j)
                (+/log (+/str " " (+/at! (+/at! m (- i 1)) j)))
                (+/log (+/str (+/at! (+/at! m i) (- j 1))
                              "?"
                              (+/at! (+/at! m i) (+ j 1))))
                (+/log (+/str " " (+/at! (+/at! m (+ i 1)) j))))
              (recur (+ 1 j)))))
        (recur (+ 1 i))))))
