(require ' ["./__test_utils__/+.mjs" :as + :refer-macros true])
(def TestProd -1)
(defn mkTestProd [a b] [-1 a b])
(def Sugar -2)
(def TestSum -3)
(defn testKey [val-1] (let [val-2 val-1 spec-3 {4 (fn [] (let [] "t:")), 5 (fn [] (let [^{:unname "d"} var-d-4 (aget val-2 2)] (+/str "d:" (+/key ^{:unname "d"} var-d-4)))), 6 (fn [] (let [^{:unname "res"} var-res-5 (aget val-2 2) ^{:unname "acc"} var-acc-6 (aget val-2 3)] (+/str "w:" (+/key ^{:unname "res"} var-res-5) "|" (+/key ^{:unname "acc"} var-acc-6))))}] ((or (aget spec-3 (aget val-2 1)) (aget spec-3 0)))))
(+/implement-key TestSum testKey)
(def TagT 4)
(def DataT 5)
(def WriterT 6)
(def Tag [-3 4])
(defn Data [d] [-3 5 d])
(defn Writer [res acc] [-3 6 res acc])
(js/describe "core data library '+'" (fn [] (js/describe "mk sugar" (fn [] (js/it (+/str "macro supports various ways of creating objects which are " "represented internally as arrays with the typeId in 0 index") (fn [] (let [x "hey" y 0 children (+/Vec 3 4 5)] ((.. (js/expect [-2 x children y]) -to-eq) [Sugar x children y]) ((.. (js/expect [-2 x children y]) -to-eq) [-2 x children y]) ((.. (js/expect [-2 x children y]) -to-eq) [-2 x children y]) ((.. (js/expect [-2 (+/mplus (+/mplus (+/mzero +/StrT) "h") "ey") (+/fplus +/VecT (+/mplus (+/mzero +/VecT) (+/Vec 3 4)) 5) (+/mzero +/NumT)]) -to-eq) [-2 x children y])))))) (js/describe "key" (fn [] (js/it "uses implementation provided by `implement-key`" (fn [] ((.. (js/expect (+/key Tag)) -to-eq) "t:") ((.. (js/expect (+/key (Data 7))) -to-eq) "d:7") ((.. (js/expect (+/key (Writer true "hi"))) -to-eq) "w:true|hi"))))) (js/describe "serializing" (fn [] (js/it "encodes to array representation with type-id in 0 index" (fn [] ((.. (js/expect (+/encode +/None)) -to-eq) (+/str "[" +/MaybeT ",null]")) ((.. (js/expect (+/encode (+/Just true))) -to-eq) (+/str "[" +/MaybeT ",true]")) ((.. (js/expect (+/encode (+/Vec 1 2 3))) -to-eq) (+/str "[" +/VecT ",1,2,3]")) ((.. (js/expect (+/encode (+/KeyedList [[1 2] [3 4]]))) -to-eq) (+/str "[" +/KeyedListT ",[1,2],[3,4]]")) ((.. (js/expect (+/encode (+/Map [[1 2] [3 4]]))) -to-eq) (+/str "[" +/MapT ",[1,2],[3,4]]")) ((.. (js/expect (+/encode (+/KeyMap [[Tag 2] [(Data 3) 4]]))) -to-eq) (+/str "[" +/KeyMapT ",[[" TestSum "," TagT "],2]," "[[" TestSum "," DataT ",3],4]]")) ((.. (js/expect (+/encode (mkTestProd 5 8))) -to-eq) (+/str "[" TestProd ",5,8]")) ((.. (js/expect (+/encode (Writer 1 "log"))) -to-eq) (+/str "[" TestSum "," WriterT ",1,\"log\"]")))) (js/it "encodes array representations recursively" (fn [] ((.. (js/expect (+/encode (mkTestProd +/None (+/Vec -1 3)))) -to-eq) (+/str "[" TestProd ",[" +/MaybeT ",null],[" +/VecT ",-1,3]]")))) (js/it "encodes to string that deocdes to structurally identical value" (fn [] (let [v-prior (+/Just (Writer (+/Vec Tag (Data (mkTestProd 2 3))) "hi")) v-after (+/decode (+/encode v-prior))] ((.. (js/expect v-prior) -to-eq) v-after) ((.. (js/expect (+/json v-prior)) -to-raw-eq) (+/json v-after))))))) (js/describe "Maybe" (fn [] (js/describe "or" (fn [] (js/it "returns value if just" (fn [] ((.. (js/expect (+/or 2 (+/Just 4))) -to-eq) 4))) (js/it "returns default value if none" (fn [] ((.. (js/expect (+/or 2 +/None)) -to-eq) 2))))) (js/describe "or-" (fn [] (js/it "only uses functions when it needs to" (fn [] (let [n-count [0] track-n (fn [] (amod n-count 0 +/inc)) fn (fn [] (track-n) 1)] ((.. (js/expect (+/or- fn (+/Just 4))) -to-eq) 4) ((.. (js/expect n-count) -to-raw-eq) [0]) ((.. (js/expect (+/or- fn +/None)) -to-eq) 1) ((.. (js/expect n-count) -to-raw-eq) [1])))))))) (js/describe "Range" (fn [] (js/it "builds vector of ints based on [end]/[init, end]/[init, end, step] args" (fn [] ((.. (js/expect (+/Range 2)) -to-eq) (+/Vec 0 1)) ((.. (js/expect (+/Range -4)) -to-eq) (+/Vec 0 -1 -2 -3)) ((.. (js/expect (+/Range 3 8)) -to-eq) (+/Vec 3 4 5 6 7)) ((.. (js/expect (+/Range -1 2)) -to-eq) (+/Vec -1 0 1)) ((.. (js/expect (+/Range 5 3)) -to-eq) (+/Vec 5 4)) ((.. (js/expect (+/Range 2 9 3)) -to-eq) (+/Vec 2 5 8)) ((.. (js/expect (+/Range 2 8 3)) -to-eq) (+/Vec 2 5)) ((.. (js/expect (+/Range 2 7 3)) -to-eq) (+/Vec 2 5)) ((.. (js/expect (+/Range 9 2 -2)) -to-eq) (+/Vec 9 7 5 3)))))) (js/describe "keys/vals" (fn [] (js/it "gets a vector of the keys or values in a collection" (fn [] ((.. (js/expect (+/keys (+/Map [[4 "a"] [5 "b"] [6 "c"]]))) -to-eq) (+/Vec 4 5 6)) ((.. (js/expect (+/keys (+/Vec "a" "b" "c"))) -to-eq) (+/Vec 0 1 2)) ((.. (js/expect (+/keys (+/Just "a"))) -to-eq) (+/Vec 0)) ((.. (js/expect (+/keys +/None)) -to-eq) (+/Vec)) ((.. (js/expect (+/vals (+/Map [[4 "a"] [5 "b"] [6 "c"]]))) -to-eq) (+/Vec "a" "b" "c")) ((.. (js/expect (+/vals (+/Vec "a" "b" "c"))) -to-eq) (+/Vec "a" "b" "c")) ((.. (js/expect (+/vals (+/Just "a"))) -to-eq) (+/Vec "a")) ((.. (js/expect (+/vals +/None)) -to-eq) (+/Vec)))) (js/it "returns fresh instance even when keys/vals just returns itself" (fn [] (let [vec1 (+/Vec (mkTestProd 1 2) (mkTestProd 3 4) (mkTestProd 5 6)) vec2 (+/vals vec1)] ((.. (js/expect vec1) -to-eq) vec2) ((.. (js/expect vec1) -not -toBe) vec2) ((.. (js/expect (.-a vec1)) -not -toBe) (.-a vec2)) ((.. (js/expect (aget (.-a vec1) 0)) -toBe) (aget (.-a vec2) 0))))))) (js/describe "fmap" (fn [] (js/it "maps function over collection" (fn [] ((.. (js/expect (+/fmap +/inc (+/Vec 0 1 2))) -to-eq) (+/Vec 1 2 3)) ((.. (js/expect (+/fmap +/inc (+/Map [[4 8] [15 16]]))) -to-eq) (+/Map [[4 9] [15 17]])) ((.. (js/expect (+/fmap +/inc (+/Just 5))) -to-eq) (+/Just 6)))) (js/it "noops on empty collection" (fn [] ((.. (js/expect (+/fmap +/inc (+/Vec))) -to-eq) (+/Vec)) ((.. (js/expect (+/fmap +/inc (+/Map))) -to-eq) (+/Map)) ((.. (js/expect (+/fmap +/inc +/None)) -to-eq) +/None))) (js/it "passes all args" (fn [] (let [fmapper (fn [coll] (+/fmap (fn [_anon%1_91 _anon%2_92 _anon%3_93] (+/Vec (+/inc _anon%1_91) _anon%2_92 (+/size _anon%3_93))) coll))] ((.. (js/expect (fmapper (+/Vec 0 1 2))) -to-eq) (+/Vec (+/Vec 1 0 3) (+/Vec 2 1 3) (+/Vec 3 2 3))) ((.. (js/expect (fmapper (+/Map [[7 0] [8 1] [9 2]]))) -to-eq) (+/Map [[7 (+/Vec 1 7 3)] [8 (+/Vec 2 8 3)] [9 (+/Vec 3 9 3)]])) ((.. (js/expect (fmapper (+/Just 1))) -to-eq) (+/Just (+/Vec 2 0 1)))))))) (js/describe "filter/remove" (fn [] (js/it "filters collection by predicate" (fn [] ((.. (js/expect (+/filter (fn [_anon%1_94] (> _anon%1_94 2)) (+/Vec 3 1 4 5 2))) -to-eq) (+/Vec 3 4 5)) ((.. (js/expect (+/filter (fn [_anon%1_95] (> _anon%1_95 2)) (+/Just 5))) -to-eq) (+/Just 5)) ((.. (js/expect (+/filter (fn [_anon%1_96] (> _anon%1_96 2)) (+/Just 1))) -to-eq) +/None) ((.. (js/expect (+/filter (fn [_anon%1_97] (> _anon%1_97 2)) +/None)) -to-eq) +/None) ((.. (js/expect (+/remove (fn [_anon%1_98] (> _anon%1_98 2)) (+/Vec 3 1 4 5 2))) -to-eq) (+/Vec 1 2)) ((.. (js/expect (+/remove (fn [_anon%1_99] (> _anon%1_99 2)) (+/Just 5))) -to-eq) +/None) ((.. (js/expect (+/remove (fn [_anon%1_100] (> _anon%1_100 2)) (+/Just 1))) -to-eq) (+/Just 1)) ((.. (js/expect (+/filter (fn [_anon%1_101] (> _anon%1_101 2)) +/None)) -to-eq) +/None))) (js/it "passes all args" (fn [] (let [filterer (+/partial +/filter (fn [_anon%1_102 _anon%2_103 _anon%3_104] (+/is 0 (+/mod (+ _anon%1_102 _anon%2_103 (+/size _anon%3_104)) 2))))] ((.. (js/expect (filterer (+/Vec 1 2 3 4))) -to-eq) (+/Vec)) ((.. (js/expect (filterer (+/Vec 1 2 3))) -to-eq) (+/Vec 1 2 3)) ((.. (js/expect (filterer (+/Vec 1 2 10 3))) -to-eq) (+/Vec 10 3)) ((.. (js/expect (filterer (+/Just 1))) -to-eq) (+/Just 1)) ((.. (js/expect (filterer (+/Just 2))) -to-eq) +/None))))))))
