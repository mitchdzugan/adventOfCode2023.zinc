(require ' ["./lib.mjs" :as lib])
(require ' ["./../+.mjs" :as + :refer-macros true])
(do (do (aset +/qt-store 18 "CubeNumsT") (+/bury +/prop-store [18 nil] {0 {:idname "red", :fullname "%red", :ind 0, :type +/NumT}, 1 {:idname "green", :fullname "%green", :ind 1, :type +/NumT}, 2 {:idname "blue", :fullname "%blue", :ind 2, :type +/NumT}})) (def CubeNumsT 18))
(defn CubeNums [red green blue] [18 red green blue])
(do (do (aset +/qt-store 19 "GameT") (+/bury +/prop-store [19 nil] {0 {:idname "id", :fullname "%id", :ind 0}, 1 {:idname "rounds", :fullname "%rounds", :ind 1, :type [+/VecT CubeNumsT]}})) (def GameT 19))
(defn cubes-power [val-1] (let [^{:unname "red"} var-red-2 (aget val-1 1) ^{:unname "green"} var-green-3 (aget val-1 2) ^{:unname "blue"} var-blue-4 (aget val-1 3)] (* ^{:unname "red"} var-red-2 ^{:unname "green"} var-green-3 ^{:unname "blue"} var-blue-4)))
(defn addColorValFromColorStr [colorVals _colorStr] (let [colorStr (.trim _colorStr) [colorValStr color] (.split colorStr " ") colorVal (js/parseInt colorValStr 10)] (+/put colorVals color colorVal)))
(defn parse-round [_roundStr] (let [roundStr (.trim _roundStr) colorVals (+/Map) colorStrs (lib/strsplit roundStr ",")] (+/each (fn [_anon%1_1] (addColorValFromColorStr colorVals _anon%1_1)) colorStrs) (CubeNums (+/or 0 (+/at colorVals "red")) (+/or 0 (+/at colorVals "green")) (+/or 0 (+/at colorVals "blue")))))
(defn parse-game [line] (let [[idStr roundsStr] (.split line ":") [_game_ idValStr] (.split idStr " ") id (js/parseInt idValStr 10) roundStrs (lib/strsplit roundsStr ";") rounds (+/fmap parse-round roundStrs)] [19 id rounds]))
(def all-cubes (CubeNums 12 13 14))
(defn valid-round? [val-5] (let [^{:unname "red"} var-red-6 (aget val-5 1) ^{:unname "green"} var-green-7 (aget val-5 2) ^{:unname "blue"} var-blue-8 (aget val-5 3)] (let [^{:unname "red"} var-red-9 (aget all-cubes 1) ^{:unname "green"} var-green-10 (aget all-cubes 2) ^{:unname "blue"} var-blue-11 (aget all-cubes 3)] (and (<= ^{:unname "red"} var-red-6 ^{:unname "red"} var-red-9) (<= ^{:unname "green"} var-green-7 ^{:unname "green"} var-green-10) (<= ^{:unname "blue"} var-blue-8 ^{:unname "blue"} var-blue-11)))))
(defn valid-game? [val-12] (let [^{:unname "rounds"} var-rounds-13 (aget val-12 2)] (+/reduce (fn [_anon%1_2 _anon%2_3] (and _anon%1_2 (valid-round? _anon%2_3))) true ^{:unname "rounds"} var-rounds-13)))
(defn to-games [input] (->> (lib/strsplit input "\n") (+/filter (fn [_anon%1_4] (not (+/is "" (.trim _anon%1_4))))) (+/fmap parse-game)))
(defn part1 [input] (->> (to-games input) (+/filter valid-game?) (+/fmap (fn [val-14] (let [^{:unname "id"} var-id-15 (aget val-14 1)] ^{:unname "id"} var-id-15))) (+/reduce (fn [_anon%1_5 _anon%2_6] (+ _anon%1_5 _anon%2_6)) 0)))
(defn update-min-cubes [acc val-16] (let [^{:unname "red"} var-red-17 (aget val-16 1) ^{:unname "green"} var-green-18 (aget val-16 2) ^{:unname "blue"} var-blue-19 (aget val-16 3)] (let [^{:unname "red"} var-red-20 (aget acc 1) ^{:unname "green"} var-green-21 (aget acc 2) ^{:unname "blue"} var-blue-22 (aget acc 3)] (let [red (.max js/Math ^{:unname "red"} var-red-20 ^{:unname "red"} var-red-17) green (.max js/Math ^{:unname "green"} var-green-21 ^{:unname "green"} var-green-18) blue (.max js/Math ^{:unname "blue"} var-blue-22 ^{:unname "blue"} var-blue-19)] (CubeNums red green blue)))))
(defn min-cubes [val-23] (let [^{:unname "rounds"} var-rounds-24 (aget val-23 2)] (+/reduce update-min-cubes (CubeNums 0 0 0) ^{:unname "rounds"} var-rounds-24)))
(defn part2 [input] (->> (to-games input) (+/fmap min-cubes) (+/fmap cubes-power) (+/reduce (fn [_anon%1_7 _anon%2_8] (+ _anon%1_7 _anon%2_8)) 0)))
(defn solve [] (let [input (lib/getInput 2)] (lib/Solution (part1 input) (part2 input))))
