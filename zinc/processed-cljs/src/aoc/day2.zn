(require ' ["./lib.mjs" :as lib])
(require ' ["./../+.mjs" :as + :refer-macros true])
(do nil (def CubeNumsT 14))
(defn CubeNums [red green blue] [14 red green blue])
(do nil (def GameT 15))
(defn cubes-power [val-82] (let [^{:unname "red"} var-red-83 (aget val-82 1) ^{:unname "green"} var-green-84 (aget val-82 2) ^{:unname "blue"} var-blue-85 (aget val-82 3)] (* ^{:unname "red"} var-red-83 ^{:unname "green"} var-green-84 ^{:unname "blue"} var-blue-85)))
(defn addColorValFromColorStr [colorVals _colorStr] (let [colorStr (.trim _colorStr) [colorValStr color] (.split colorStr " ") colorVal (lib/parseInt colorValStr)] (+/put colorVals color colorVal)))
(defn parse-round [_roundStr] (let [roundStr (.trim _roundStr) colorVals (+/Map) colorStrs (lib/strsplit roundStr ",")] (+/each (fn [_anon%1_74] (addColorValFromColorStr colorVals _anon%1_74)) colorStrs) (CubeNums (+/or 0 (+/at colorVals "red")) (+/or 0 (+/at colorVals "green")) (+/or 0 (+/at colorVals "blue")))))
(defn parse-game [line] (let [[idStr roundsStr] (.split line ":") [_game_ idValStr] (.split idStr " ") id (lib/parseInt idValStr) roundStrs (lib/strsplit roundsStr ";") rounds (+/fmap parse-round roundStrs)] [15 id rounds]))
(def all-cubes (CubeNums 12 13 14))
(defn valid-round? [val-86] (let [^{:unname "red"} var-red-87 (aget val-86 1) ^{:unname "green"} var-green-88 (aget val-86 2) ^{:unname "blue"} var-blue-89 (aget val-86 3)] (let [^{:unname "red"} var-red-90 (aget all-cubes 1) ^{:unname "green"} var-green-91 (aget all-cubes 2) ^{:unname "blue"} var-blue-92 (aget all-cubes 3)] (and (<= ^{:unname "red"} var-red-87 ^{:unname "red"} var-red-90) (<= ^{:unname "green"} var-green-88 ^{:unname "green"} var-green-91) (<= ^{:unname "blue"} var-blue-89 ^{:unname "blue"} var-blue-92)))))
(defn valid-game? [val-93] (let [^{:unname "rounds"} var-rounds-94 (aget val-93 2)] (+/reduce (fn [_anon%1_75 _anon%2_76] (and _anon%1_75 (valid-round? _anon%2_76))) true ^{:unname "rounds"} var-rounds-94)))
(defn to-games [input] (->> (lib/strsplit input "\n") (+/filter (fn [_anon%1_77] (not (+/is "" (.trim _anon%1_77))))) (+/fmap parse-game)))
(defn part1 [input] (->> (to-games input) (+/filter valid-game?) (+/fmap (fn [val-95] (let [^{:unname "id"} var-id-96 (aget val-95 1)] ^{:unname "id"} var-id-96))) (+/reduce (fn [_anon%1_78 _anon%2_79] (+ _anon%1_78 _anon%2_79)) 0)))
(defn update-min-cubes [acc val-97] (let [^{:unname "red"} var-red-98 (aget val-97 1) ^{:unname "green"} var-green-99 (aget val-97 2) ^{:unname "blue"} var-blue-100 (aget val-97 3)] (let [^{:unname "red"} var-red-101 (aget acc 1) ^{:unname "green"} var-green-102 (aget acc 2) ^{:unname "blue"} var-blue-103 (aget acc 3)] (let [red (.max js/Math ^{:unname "red"} var-red-101 ^{:unname "red"} var-red-98) green (.max js/Math ^{:unname "green"} var-green-102 ^{:unname "green"} var-green-99) blue (.max js/Math ^{:unname "blue"} var-blue-103 ^{:unname "blue"} var-blue-100)] (CubeNums red green blue)))))
(defn min-cubes [val-104] (let [^{:unname "rounds"} var-rounds-105 (aget val-104 2)] (+/reduce update-min-cubes (CubeNums 0 0 0) ^{:unname "rounds"} var-rounds-105)))
(defn part2 [input] (->> (to-games input) (+/fmap min-cubes) (+/fmap cubes-power) (+/reduce (fn [_anon%1_80 _anon%2_81] (+ _anon%1_80 _anon%2_81)) 0)))
