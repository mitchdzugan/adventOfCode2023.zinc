(require ' ["./lib.mjs" :as lib])
(require ' ["./../+.mjs" :as + :refer-macros true])
(do (do (aset +/qt-store 13 "CardT") (+/bury +/prop-store [13 nil] {0 {:idname "id", :fullname "%id", :ind 0}, 1 {:idname "winning", :fullname "%winning", :ind 1, :type [+/SetT +/NumT]}, 2 {:idname "my", :fullname "%my", :ind 2, :type [+/SetT +/NumT]}})) (def CardT 13))
(defn cardId [val-18] (let [^{:unname "id"} var-id-19 (aget val-18 1)] ^{:unname "id"} var-id-19))
(defn parseCard [line] (let [[idLabelStr numDataStr] (.split line ":") [_cardStr idStr] (.split (.trim idLabelStr) lib/rx_whitespace) id (lib/parseInt idStr) [winningNumStr myNumStr] (.split (.trim numDataStr) "|") toSet (fn [numStr] (as-> numStr $ (.split (.trim $) lib/rx_whitespace) (.map $ lib/parseInt) (+/apply +/Set $))) winning (toSet winningNumStr) my (toSet myNumStr)] [13 id winning my]))
(defn myWinCount [val-20] (let [^{:unname "winning"} var-winning-21 (aget val-20 2) ^{:unname "my"} var-my-22 (aget val-20 3)] (+/size (+/intersection ^{:unname "winning"} var-winning-21 ^{:unname "my"} var-my-22))))
(defn cardValue [card] (->> (myWinCount card) (+ -1) (js/Math.pow 2) js/Math.floor))
(defn parseCards [input] (->> (lib/strsplit input "\n") (+/filter (fn [_anon%1_108] (not (+/is "" (.trim _anon%1_108))))) (+/fmap parseCard)))
(defn part1 [input] (->> (parseCards input) (+/fmap cardValue) (+/reduce (fn [_anon%1_109 _anon%2_110] (+ _anon%1_109 _anon%2_110)) 0)))
(defn scratchCardsWonByCard [card cardsById] (->> (+/Range (myWinCount card)) (+/fmap (fn [_anon%1_111] (scratchCardsWonById (+ (cardId card) 1 _anon%1_111) cardsById))) (+/reduce (fn [_anon%1_112 _anon%2_113] (+ _anon%1_112 _anon%2_113)) 1)))
(let [scratchCardsWonById-impl-18 (fn [id cardsById] (->> (+/at cardsById id) (+/fmap (fn [_anon%1_114] (scratchCardsWonByCard _anon%1_114 cardsById))) (+/or 0))) scratchCardsWonById-memo-20 (+/Map)] (defn scratchCardsWonById [& scratchCardsWonById-args-19] (let [scratchCardsWonById-mkey-17 (+/encode (+/fmap +/forcedKey (+/apply +/Vec scratchCardsWonById-args-19))) scratchCardsWonById-rtrn-16 (+/or- (fn [] (+/apply scratchCardsWonById-impl-18 scratchCardsWonById-args-19)) (+/at scratchCardsWonById-memo-20 scratchCardsWonById-mkey-17))] (+/put scratchCardsWonById-memo-20 scratchCardsWonById-mkey-17 scratchCardsWonById-rtrn-16) scratchCardsWonById-rtrn-16)))
(defn part2 [input] (let [cards (parseCards input) cardsById (+/keyBy cardId cards)] (->> (+/keys cardsById) (+/fmap (fn [_anon%1_115] (scratchCardsWonById _anon%1_115 cardsById))) (+/reduce (fn [_anon%1_116 _anon%2_117] (+ _anon%1_116 _anon%2_117)) 0))))
