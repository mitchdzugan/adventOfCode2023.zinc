(require ' ["./lib.mjs" :as lib])
(require ' ["./../+.mjs" :as + :refer-macros true])
(defn emptyXs [line] (let [res (+/Set)] (+/for (lib/strsplit line "") (fn [_anon%1_37 _anon%2_38] (when (= "." _anon%1_37) (+/push res _anon%2_38)))) res))
(defn make-grid [input] (let [rmemptyCols (aref +/None) joinEmptyXs (->> memptyCols (+/fmap (fn [_anon%1_39] (+/Just (+/intersection xs _anon%1_39)))) (+/or (+/Just xs)) (fn [memptyCols]) (a#= rmemptyCols) (fn [xs])) emptyCols (fn [] (+/unwrap! (aget rmemptyCols "r")))] (->> (+/filter (fn [_anon%1_40] (not= (.trim _anon%1_40) "")) (lib/strsplit input "\n")) (+/fmap (fn [_anon%1_41] (->> (.replaceAll _anon%1_41 "." "x") (if-not (= (.-length _anon%1_41) (+/size xs)) _anon%1_41) (let [xs (emptyXs _anon%1_41)] (joinEmptyXs xs))))) (+/fmap (fn [line] (->> (lib/strsplit line "") (+/fmap (fn [_anon%1_43 _anon%2_42] (if (+/has? (emptyCols) _anon%2_42) "x" _anon%1_43)))))))))
(do nil (def GalaxyT 36))
(defn Galaxy [id x y] [36 id x y])
(defn gx [val-148] (let [^{:unname "x"} var-x-149 (aget val-148 2)] ^{:unname "x"} var-x-149))
(defn gy [val-150] (let [^{:unname "y"} var-y-151 (aget val-150 3)] ^{:unname "y"} var-y-151))
(defn distance [g1 g2] (+ (js/Math.abs (- (gx g1) (gx g2))) (js/Math.abs (- (gy g1) (gy g2)))))
(defn get-galaxies [grid expandBy] (let [galaxies (+/Vec) nextId (fn [] (+/size galaxies))] (->> (if (>= i (+/size row)) (+ y 1 (if allX? expandBy 0)) (let [c (+/at! row i)] (cond (= "#" c) (do (+/push galaxies (Galaxy (nextId) x y)) (recur (+ i 1) (+ x 1) false)) (= "." c) (recur (+ i 1) (+ x 1) false) (= "x" c) (recur (+ i 1) (+ x 1 expandBy) allX?)))) (loop [i 0 x 0 allX? true]) (recur (+ j 1)) (let [row (+/at! grid j)]) (when (< j (+/size grid))) (loop [j 0 y 0])) galaxies))
(defn calc-sum [input expandBy] (let [grid (make-grid input) galaxies (get-galaxies grid expandBy)] (->> galaxies (+/bind (fn [_anon%1_44 _anon%2_45] (+/fmap (fn [g2] (distance _anon%1_44 g2)) (+/slice galaxies (+ 1 _anon%2_45))))) (+/reduce (fn [_anon%1_46 _anon%2_47] (+ _anon%1_46 _anon%2_47)) 0))))
(defn part1 [input] (calc-sum input 1))
(defn part2 [input] (calc-sum input (- 1000000 1)))
