(require ' ["./lib.mjs" :as lib])
(require ' ["./../+.mjs" :as + :refer-macros true])
(defn emptyXs [line] (let [res (+/Set)] (+/for (lib/strsplit line "") (fn [_anon%1_45 _anon%2_46] (when (= "." _anon%1_45) (+/push res _anon%2_46)))) res))
(defn make-grid [input] (let [rmemptyCols (aref +/None) joinEmptyXs (->> memptyCols (+/fmap (fn [_anon%1_47] (+/Just (+/intersection xs _anon%1_47)))) (+/or (+/Just xs)) (fn [memptyCols]) (a#= rmemptyCols) (fn [xs])) emptyCols (fn [] (+/unwrap! (aget rmemptyCols "r")))] (->> (+/filter (fn [_anon%1_48] (not= (.trim _anon%1_48) "")) (lib/strsplit input "\n")) (+/fmap (fn [_anon%1_49] (->> (.replaceAll _anon%1_49 "." "x") (if-not (= (.-length _anon%1_49) (+/size xs)) _anon%1_49) (let [xs (emptyXs _anon%1_49)] (joinEmptyXs xs))))) (+/fmap (fn [line] (->> (lib/strsplit line "") (+/fmap (fn [_anon%1_51 _anon%2_50] (if (+/has? (emptyCols) _anon%2_50) "x" _anon%1_51)))))))))
(do (do (aset +/qt-store 36 "GalaxyT") (+/bury +/prop-store [36 nil] {0 {:idname "id", :fullname "%id", :ind 0}, 1 {:idname "x", :fullname "%x", :ind 1}, 2 {:idname "y", :fullname "%y", :ind 2}})) (def GalaxyT 36))
(defn Galaxy [id x y] [36 id x y])
(defn gx [val-148] (let [^{:unname "x"} var-x-149 (aget val-148 2)] ^{:unname "x"} var-x-149))
(defn gy [val-150] (let [^{:unname "y"} var-y-151 (aget val-150 3)] ^{:unname "y"} var-y-151))
(defn distance [g1 g2] (+ (js/Math.abs (- (gx g1) (gx g2))) (js/Math.abs (- (gy g1) (gy g2)))))
(defn get-galaxies [grid expandBy] (let [galaxies (+/Vec) nextId (fn [] (+/size galaxies))] (->> (if (>= i (+/size row)) (+ y 1 (if allX? expandBy 0)) (let [c (+/at! row i)] (cond (= "#" c) (do (+/push galaxies (Galaxy (nextId) x y)) (recur (+ i 1) (+ x 1) false)) (= "." c) (recur (+ i 1) (+ x 1) false) (= "x" c) (recur (+ i 1) (+ x 1 expandBy) allX?)))) (loop [i 0 x 0 allX? true]) (recur (+ j 1)) (let [row (+/at! grid j)]) (when (< j (+/size grid))) (loop [j 0 y 0])) galaxies))
(defn calc-sum [input expandBy] (let [grid (make-grid input) galaxies (get-galaxies grid expandBy)] (->> galaxies (+/bind (fn [_anon%1_52 _anon%2_53] (+/fmap (fn [g2] (distance _anon%1_52 g2)) (+/slice galaxies (+ 1 _anon%2_53))))) (+/reduce (fn [_anon%1_54 _anon%2_55] (+ _anon%1_54 _anon%2_55)) 0))))
(defn part1 [input] (calc-sum input 1))
(defn part2 [input] (calc-sum input (- 1000000 1)))
