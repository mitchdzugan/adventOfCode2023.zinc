(require ' ["./lib.mjs" :as lib])
(require ' ["./../+.mjs" :as + :refer-macros true])
(do nil (def InputDataT 19))
(defn InputData [initials category-maps] [19 initials category-maps])
(do nil (def GuideT 20))
(defn Guide [id offset] [20 id offset])
(defn guide-id [val-64] (let [^{:unname "id"} var-id-65 (aget val-64 1)] ^{:unname "id"} var-id-65))
(defn offset [val-66] (let [^{:unname "offset"} var-offset-67 (aget val-66 2)] ^{:unname "offset"} var-offset-67))
(do nil (def InitialT 21))
(defn Item [category id] [21 1 category id])
(defn Range [category start length] [21 2 category start length])
(do nil (def CategoryMapT 22))
(defn init-category-map [src dst] [22 src dst (+/Vec)])
(defn destination [val-68] (let [^{:unname "dst"} var-dst-69 (aget val-68 2)] ^{:unname "dst"} var-dst-69))
(defn guides [val-70] (let [^{:unname "guides"} var-guides-71 (aget val-70 3)] ^{:unname "guides"} var-guides-71))
(defn push-guide [val-72 guide] (let [^{:unname "guides"} var-guides-73 (aget val-72 3)] (+/push ^{:unname "guides"} var-guides-73 guide)))
(do nil (def InputLineT 23))
(defn parse-initial-seeds [line] (let [[_seeds ids_str] (.split line ":")] (as-> (.trim ids_str) $ (lib/strsplit $ lib/rx_whitespace) (+/fmap lib/parseInt $) [23 2 $])))
(defn parse-map-header [line] (let [[categories_str] (.split line lib/rx_whitespace) [from _to_ to] (.split categories_str "-")] [23 3 from to]))
(defn parse-map-entry [line] (let [[dst src length] (.map (.split line lib/rx_whitespace) lib/parseInt)] [23 4 dst src length]))
(defn parse-line [line] (cond (= "" (.trim line)) [23 1] (.startsWith line "seeds:") (parse-initial-seeds line) (.endsWith (.trim line) "map:") (parse-map-header line) :else (parse-map-entry line)))
(let [get-guide-ind-impl-23 (fn [id guides] (let [get-id (fn [_anon%1_15] (guide-id (+/at! guides _anon%1_15)))] (loop [lbound 0 rbound (- (+/size guides) 1)] (cond (< id (get-id lbound)) +/None (>= id (get-id rbound)) (+/Just rbound) (<= (- rbound lbound) 1) (+/Just lbound) :else (let [mbound (+ lbound (+/floor (+/div (- rbound lbound) 2)))] (cond (+/is id (get-id mbound)) (+/Just mbound) (< id (get-id mbound)) (recur lbound mbound) :else (recur mbound rbound))))))) get-guide-ind-memo-25 (+/Map)] (defn get-guide-ind [& get-guide-ind-args-24] (let [get-guide-ind-mkey-22 (+/encode (+/fmap +/forcedKey (+/apply +/Vec get-guide-ind-args-24))) get-guide-ind-rtrn-21 (+/or- (fn [] (+/apply get-guide-ind-impl-23 get-guide-ind-args-24)) (+/at get-guide-ind-memo-25 get-guide-ind-mkey-22))] (+/put get-guide-ind-memo-25 get-guide-ind-mkey-22 get-guide-ind-rtrn-21) get-guide-ind-rtrn-21)))
(defn get-offset [id guides] (->> (get-guide-ind id guides) (+/fmap (fn [_anon%1_16] (offset (+/at! guides _anon%1_16)))) (+/or 0)))
(defn get-associated-item [category-maps category id] (let [cat-map (+/at! category-maps category)] (Item (destination cat-map) (+ id (get-offset id (guides cat-map))))))
(defn get-associated-ranges [category-maps category start length] (let [cat-map (+/at! category-maps category) cat-guides (guides cat-map) dst (destination cat-map) mk-range (fn [_anon%1_17 _anon%2_18] (Range dst _anon%1_17 _anon%2_18)) get-id (fn [_anon%1_19] (guide-id (+/at! cat-guides _anon%1_19))) get-offset (fn [_anon%1_20] (offset (+/at! cat-guides _anon%1_20))) results (+/Vec) end (+ start length) oob? (fn [_anon%1_21] (>= _anon%1_21 end))] (loop [id start m-ind (get-guide-ind start cat-guides)] (let [off (+/or 0 (+/fmap get-offset m-ind)) ind (+/or 0 (+/fmap +/inc m-ind))] (if (or (>= ind (+/size cat-guides)) (oob? (get-id ind))) (+/push results (mk-range (+ id off) (- end id))) (let [next-id (get-id ind)] (+/push results (mk-range (+ id off) (- next-id id))) (recur next-id (+/Just ind)))))) results))
(defn get-location [category-maps val-74] (let [val-75 val-74 spec-76 {1 (fn [] (let [^{:unname "category"} var-category-77 (aget val-75 2) ^{:unname "id"} var-id-78 (aget val-75 3)] (->> (get-associated-item category-maps ^{:unname "category"} var-category-77 ^{:unname "id"} var-id-78) (get-location category-maps) (if (+/is "location" ^{:unname "category"} var-category-77) ^{:unname "id"} var-id-78)))), 2 (fn [] (let [^{:unname "category"} var-category-79 (aget val-75 2) ^{:unname "start"} var-start-80 (aget val-75 3) ^{:unname "length"} var-length-81 (aget val-75 4)] (->> (get-associated-ranges category-maps ^{:unname "category"} var-category-79 ^{:unname "start"} var-start-80 ^{:unname "length"} var-length-81) (min-location category-maps) (if (+/is "location" ^{:unname "category"} var-category-79) ^{:unname "start"} var-start-80))))}] ((or (aget spec-76 (aget val-75 1)) (aget spec-76 0)))))
(defn min-location [category-maps initials] (let [] (->> (+/fmap (fn [initial] (get-location category-maps initial)) initials) (+/reduce (fn [acc loc] (+/Just (+/min (+/or loc acc) loc))) +/None) (+/unwrap!))))
(defn min-location-for-input [val-82] (let [^{:unname "category-maps"} var-category-maps-83 (aget val-82 2) ^{:unname "initials"} var-initials-84 (aget val-82 1)] (min-location ^{:unname "category-maps"} var-category-maps-83 ^{:unname "initials"} var-initials-84)))
(defn parse-input [input ranges?] (let [rsrc (aref "") rmap (aref (+/Map)) rinitials (aref (+/Vec)) category-maps (+/Map) inputs (->> (lib/strsplit input "\n") (+/fmap parse-line)) finalize-category-map (fn [] (->> (+/at category-maps (aget rsrc "r")) (+/each (fn [cat-map] (->> (+/vals (+/fmap (fn [_anon%1_23 _anon%2_22] (Guide _anon%2_22 _anon%1_23)) (aget rmap "r"))) (+/sort-by guide-id) (+/each (fn [_anon%1_24] (push-guide cat-map _anon%1_24))))))) (a= rmap (+/Map)))] (-> (fn [val-85] (let [val-86 val-85 spec-87 {2 (fn [] (let [^{:unname "seeds"} var-seeds-88 (aget val-86 2)] (a= rinitials (if ranges? (->> (+/Range (+/floor (+/div (+/size ^{:unname "seeds"} var-seeds-88) 2))) (+/fmap (fn [n] (Range "seed" (+/at! ^{:unname "seeds"} var-seeds-88 (+ 0 (* 2 n))) (+/at! ^{:unname "seeds"} var-seeds-88 (+ 1 (* 2 n))))))) (+/fmap (fn [id] (Item "seed" id)) ^{:unname "seeds"} var-seeds-88))))), 3 (fn [] (let [^{:unname "from"} var-from-89 (aget val-86 2) ^{:unname "to"} var-to-90 (aget val-86 3)] (finalize-category-map) (+/put category-maps ^{:unname "from"} var-from-89 (init-category-map ^{:unname "from"} var-from-89 ^{:unname "to"} var-to-90)) (a= rsrc ^{:unname "from"} var-from-89))), 4 (fn [] (let [^{:unname "dst"} var-dst-91 (aget val-86 2) ^{:unname "src"} var-src-92 (aget val-86 3) ^{:unname "length"} var-length-93 (aget val-86 4)] (let [offset (- ^{:unname "dst"} var-dst-91 ^{:unname "src"} var-src-92) end (+ ^{:unname "src"} var-src-92 ^{:unname "length"} var-length-93)] (+/put (aget rmap "r") ^{:unname "src"} var-src-92 offset) (+/put (aget rmap "r") end (+/or 0 (+/at (aget rmap "r") end)))))), 0 (fn [] (let []))}] ((or (aget spec-87 (aget val-86 1)) (aget spec-87 0))))) (+/each inputs)) (finalize-category-map) (InputData (aget rinitials "r") category-maps)))
(defn part1 [input] (-> input (parse-input false) min-location-for-input))
(defn part2 [input] (-> input (parse-input true) min-location-for-input))
