(require ' ["./lib.mjs" :as lib])
(require ' ["./../+.mjs" :as + :refer-macros true])
(do nil (def InputDataT 14))
(defn InputData [initials category-maps] [14 initials category-maps])
(do nil (def GuideT 15))
(defn Guide [id offset] [15 id offset])
(defn guide-id [val-23] (let [^{:unname "id"} var-id-24 (aget val-23 1)] ^{:unname "id"} var-id-24))
(defn offset [val-25] (let [^{:unname "offset"} var-offset-26 (aget val-25 2)] ^{:unname "offset"} var-offset-26))
(do nil (def InitialT 16))
(defn Item [category id] [16 1 category id])
(defn Range [category start length] [16 2 category start length])
(do nil (def CategoryMapT 17))
(defn init-category-map [src dst] [17 src dst (+/Vec)])
(defn destination [val-27] (let [^{:unname "dst"} var-dst-28 (aget val-27 2)] ^{:unname "dst"} var-dst-28))
(defn guides [val-29] (let [^{:unname "guides"} var-guides-30 (aget val-29 3)] ^{:unname "guides"} var-guides-30))
(defn push-guide [val-31 guide] (let [^{:unname "guides"} var-guides-32 (aget val-31 3)] (+/push ^{:unname "guides"} var-guides-32 guide)))
(do nil (def InputLineT 18))
(defn parse-initial-seeds [line] (let [[_seeds ids_str] (.split line ":")] (as-> (.trim ids_str) $ (lib/strsplit $ lib/rx_whitespace) (+/fmap lib/parseInt $) [18 2 $])))
(defn parse-map-header [line] (let [[categories_str] (.split line lib/rx_whitespace) [from _to_ to] (.split categories_str "-")] [18 3 from to]))
(defn parse-map-entry [line] (let [[dst src length] (.map (.split line lib/rx_whitespace) lib/parseInt)] [18 4 dst src length]))
(defn parse-line [line] (cond (= "" (.trim line)) [18 1] (.startsWith line "seeds:") (parse-initial-seeds line) (.endsWith (.trim line) "map:") (parse-map-header line) :else (parse-map-entry line)))
(let [get-guide-ind-impl-23 (fn [id guides] (let [get-id (fn [_anon%1_90] (guide-id (+/at! guides _anon%1_90)))] (loop [lbound 0 rbound (- (+/size guides) 1)] (cond (< id (get-id lbound)) +/None (>= id (get-id rbound)) (+/Just rbound) (<= (- rbound lbound) 1) (+/Just lbound) :else (let [mbound (+ lbound (+/floor (/ (- rbound lbound) 2)))] (cond (+/is id (get-id mbound)) (+/Just mbound) (< id (get-id mbound)) (recur lbound mbound) :else (recur mbound rbound))))))) get-guide-ind-memo-25 (+/Map)] (defn get-guide-ind [& get-guide-ind-args-24] (let [get-guide-ind-mkey-22 (+/encode (+/fmap +/forcedKey (+/apply +/Vec get-guide-ind-args-24))) get-guide-ind-rtrn-21 (+/or- (fn [] (+/apply get-guide-ind-impl-23 get-guide-ind-args-24)) (+/at get-guide-ind-memo-25 get-guide-ind-mkey-22))] (+/put get-guide-ind-memo-25 get-guide-ind-mkey-22 get-guide-ind-rtrn-21) get-guide-ind-rtrn-21)))
(defn get-offset [id guides] (->> (get-guide-ind id guides) (+/fmap (fn [_anon%1_91] (offset (+/at! guides _anon%1_91)))) (+/or 0)))
(defn get-associated-item [category-maps category id] (let [cat-map (+/at! category-maps category)] (Item (destination cat-map) (+ id (get-offset id (guides cat-map))))))
(defn get-associated-ranges [category-maps category start length] (let [cat-map (+/at! category-maps category) cat-guides (guides cat-map) dst (destination cat-map) mk-range (fn [_anon%1_92 _anon%2_93] (Range dst _anon%1_92 _anon%2_93)) get-id (fn [_anon%1_94] (guide-id (+/at! cat-guides _anon%1_94))) get-offset (fn [_anon%1_95] (offset (+/at! cat-guides _anon%1_95))) results (+/Vec) end (+ start length) oob? (fn [_anon%1_96] (>= _anon%1_96 end))] (loop [id start m-ind (get-guide-ind start cat-guides)] (let [off (+/or 0 (+/fmap get-offset m-ind)) ind (+/or 0 (+/fmap +/inc m-ind))] (if (or (>= ind (+/size cat-guides)) (oob? (get-id ind))) (+/push results (mk-range (+ id off) (- end id))) (let [next-id (get-id ind)] (+/push results (mk-range (+ id off) (- next-id id))) (recur next-id (+/Just ind)))))) results))
(defn get-location [category-maps val-33] (let [val-34 val-33 spec-35 {1 (fn [] (let [^{:unname "category"} var-category-36 (aget val-34 2) ^{:unname "id"} var-id-37 (aget val-34 3)] (->> (get-associated-item category-maps ^{:unname "category"} var-category-36 ^{:unname "id"} var-id-37) (get-location category-maps) (if (+/is "location" ^{:unname "category"} var-category-36) ^{:unname "id"} var-id-37)))), 2 (fn [] (let [^{:unname "category"} var-category-38 (aget val-34 2) ^{:unname "start"} var-start-39 (aget val-34 3) ^{:unname "length"} var-length-40 (aget val-34 4)] (->> (get-associated-ranges category-maps ^{:unname "category"} var-category-38 ^{:unname "start"} var-start-39 ^{:unname "length"} var-length-40) (min-location category-maps) (if (+/is "location" ^{:unname "category"} var-category-38) ^{:unname "start"} var-start-39))))}] ((or (aget spec-35 (aget val-34 1)) (aget spec-35 0)))))
(defn min-location [category-maps initials] (let [] (->> (+/fmap (fn [initial] (get-location category-maps initial)) initials) (+/reduce (fn [acc loc] (+/Just (+/min (+/or loc acc) loc))) +/None) (+/unwrap!))))
(defn min-location-for-input [val-41] (let [^{:unname "category-maps"} var-category-maps-42 (aget val-41 2) ^{:unname "initials"} var-initials-43 (aget val-41 1)] (min-location ^{:unname "category-maps"} var-category-maps-42 ^{:unname "initials"} var-initials-43)))
(defn parse-input [input ranges?] (let [rsrc (aref "") rmap (aref (+/Map)) rinitials (aref (+/Vec)) category-maps (+/Map) inputs (->> (lib/strsplit input "\n") (+/fmap parse-line)) finalize-category-map (fn [] (->> (+/at category-maps (aget rsrc "r")) (+/each (fn [cat-map] (->> (+/vals (+/fmap (fn [_anon%1_98 _anon%2_97] (Guide _anon%2_97 _anon%1_98)) (aget rmap "r"))) (+/sort-by guide-id) (+/each (fn [_anon%1_99] (push-guide cat-map _anon%1_99))))))) (a= rmap (+/Map)))] (-> (fn [val-44] (let [val-45 val-44 spec-46 {2 (fn [] (let [^{:unname "seeds"} var-seeds-47 (aget val-45 2)] (a= rinitials (if ranges? (->> (+/Range (+/floor (/ (+/size ^{:unname "seeds"} var-seeds-47) 2))) (+/fmap (fn [n] (Range "seed" (+/at! ^{:unname "seeds"} var-seeds-47 (+ 0 (* 2 n))) (+/at! ^{:unname "seeds"} var-seeds-47 (+ 1 (* 2 n))))))) (+/fmap (fn [id] (Item "seed" id)) ^{:unname "seeds"} var-seeds-47))))), 3 (fn [] (let [^{:unname "from"} var-from-48 (aget val-45 2) ^{:unname "to"} var-to-49 (aget val-45 3)] (finalize-category-map) (+/put category-maps ^{:unname "from"} var-from-48 (init-category-map ^{:unname "from"} var-from-48 ^{:unname "to"} var-to-49)) (a= rsrc ^{:unname "from"} var-from-48))), 4 (fn [] (let [^{:unname "dst"} var-dst-50 (aget val-45 2) ^{:unname "src"} var-src-51 (aget val-45 3) ^{:unname "length"} var-length-52 (aget val-45 4)] (let [offset (- ^{:unname "dst"} var-dst-50 ^{:unname "src"} var-src-51) end (+ ^{:unname "src"} var-src-51 ^{:unname "length"} var-length-52)] (+/put (aget rmap "r") ^{:unname "src"} var-src-51 offset) (+/put (aget rmap "r") end (+/or 0 (+/at (aget rmap "r") end)))))), 0 (fn [] (let []))}] ((or (aget spec-46 (aget val-45 1)) (aget spec-46 0))))) (+/each inputs)) (finalize-category-map) (InputData (aget rinitials "r") category-maps)))
(defn part1 [input] (-> input (parse-input false) min-location-for-input))
(defn part2 [input] (-> input (parse-input true) min-location-for-input))
