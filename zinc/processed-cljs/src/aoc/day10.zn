(require ' ["./lib.mjs" :as lib])
(require ' ["./../+.mjs" :as + :refer-macros true])
(do nil (def DirT 34))
(def Left [34 3])
(def Right [34 4])
(def Up [34 1])
(def Down [34 2])
(do nil (def PosT 33))
(defn Pos [x y] [33 x y])
(def INITIAL_POS (Pos 74 82))
(def INITIAL_DIR Up)
(def TRUE_S_CHAR "7")
(defn pipe-at [m val-107 preserveS?] (let [^{:unname "y"} var-y-108 (aget val-107 2) ^{:unname "x"} var-x-109 (aget val-107 1)] (let [res (+/at! (+/at! m ^{:unname "y"} var-y-108) ^{:unname "x"} var-x-109)] (cond preserveS? res (+/is res "S") TRUE_S_CHAR :else res))))
(defn step-pos [val-110 dir] (let [^{:unname "x"} var-x-111 (aget val-110 1) ^{:unname "y"} var-y-112 (aget val-110 2)] (let [x ^{:unname "x"} var-x-111 y ^{:unname "y"} var-y-112] (let [val-113 dir spec-114 {3 (fn [] (let [] (Pos (- x 1) y))), 4 (fn [] (let [] (Pos (+ x 1) y))), 1 (fn [] (let [] (Pos x (- y 1)))), 2 (fn [] (let [] (Pos x (+ y 1))))}] ((or (aget spec-114 (aget val-113 1)) (aget spec-114 0)))))))
(do nil (def InstT 35))
(defn Inst [m pos dir] [35 m pos dir])
(defn inst-pos [val-115] (let [^{:unname "pos"} var-pos-116 (aget val-115 2)] ^{:unname "pos"} var-pos-116))
(defn step [val-117] (let [^{:unname "m"} var-m-118 (aget val-117 1) ^{:unname "pos"} var-pos-119 (aget val-117 2) ^{:unname "dir"} var-dir-120 (aget val-117 3)] (let [ndir (next-dir (pipe-at ^{:unname "m"} var-m-118 ^{:unname "pos"} var-pos-119) ^{:unname "dir"} var-dir-120)] (Inst ^{:unname "m"} var-m-118 (step-pos ^{:unname "pos"} var-pos-119 ndir) ndir))))
(defn next-dir [c dir] (cond (+/is c "-") (let [val-121 dir spec-122 {3 (fn [] (let [] Left)), 4 (fn [] (let [] Right))}] ((or (aget spec-122 (aget val-121 1)) (aget spec-122 0)))) (+/is c "7") (let [val-123 dir spec-124 {1 (fn [] (let [] Left)), 4 (fn [] (let [] Down))}] ((or (aget spec-124 (aget val-123 1)) (aget spec-124 0)))) (+/is c "|") (let [val-125 dir spec-126 {1 (fn [] (let [] Up)), 2 (fn [] (let [] Down))}] ((or (aget spec-126 (aget val-125 1)) (aget spec-126 0)))) (+/is c "J") (let [val-127 dir spec-128 {2 (fn [] (let [] Left)), 4 (fn [] (let [] Up))}] ((or (aget spec-128 (aget val-127 1)) (aget spec-128 0)))) (+/is c "L") (let [val-129 dir spec-130 {2 (fn [] (let [] Right)), 3 (fn [] (let [] Up))}] ((or (aget spec-130 (aget val-129 1)) (aget spec-130 0)))) (+/is c "F") (let [val-131 dir spec-132 {1 (fn [] (let [] Right)), 3 (fn [] (let [] Down))}] ((or (aget spec-132 (aget val-131 1)) (aget spec-132 0))))))
(defn parse-input [input] (let [m (+/fmap (fn [_anon%1_42] (lib/strsplit _anon%1_42 "")) (lib/strsplit input "\n"))] [m (Inst m INITIAL_POS INITIAL_DIR)]))
(defn start? [val-133] (let [^{:unname "m"} var-m-134 (aget val-133 1) ^{:unname "pos"} var-pos-135 (aget val-133 2)] (+/is "S" (pipe-at ^{:unname "m"} var-m-134 ^{:unname "pos"} var-pos-135 true))))
(defn part1 [input] (let [[m initial] (parse-input input)] (loop [inst (step initial) steps 1] (if (start? inst) (+/floor (/ steps 2)) (recur (step inst) (+ 1 steps))))))
(defn init-matrix [rows cols init] (let [res (+/Vec)] (loop [y 0] (when (< y cols) (let [row (+/Vec)] (loop [x 0] (when (< x rows) (+/push row init) (recur (+ x 1)))) (+/push res row)) (recur (+ y 1)))) res))
(defn inflate-char [c] (cond (+/is c "-") ["..." "---" "..."] (+/is c "7") ["..." "-7." ".|."] (+/is c "|") [".|." ".|." ".|."] (+/is c "J") [".|." "-J." "..."] (+/is c "L") [".|." ".L-" "..."] (+/is c "F") ["..." ".F-" ".|."]))
(defn set-at-pos [src val-136 v] (let [^{:unname "y"} var-y-137 (aget val-136 2) ^{:unname "x"} var-x-138 (aget val-136 1)] (+/put (+/at! src ^{:unname "y"} var-y-137) ^{:unname "x"} var-x-138 v)))
(defn get-at-pos [src val-139] (let [^{:unname "y"} var-y-140 (aget val-139 2) ^{:unname "x"} var-x-141 (aget val-139 1)] (+/at! (+/at! src ^{:unname "y"} var-y-140) ^{:unname "x"} var-x-141)))
(defn inflate [val-142 src dst] (let [^{:unname "y"} var-y-143 (aget val-142 2) ^{:unname "x"} var-x-144 (aget val-142 1)] (let [grid (inflate-char (pipe-at src val-142)) put (fn [x y] (+/put (+/at! dst (+ y (* 3 ^{:unname "y"} var-y-143))) (+ x (* 3 ^{:unname "x"} var-x-144)) (aget grid y x)))] (+/for (+/Vec 0 1 2) (fn [x] (put x 0) (put x 1) (put x 2))))))
(defn fill-unenclosed [expanded checked enclosed] (let [] (loop [stack [[0 0]]] (when (> (.-length stack) 0) (let [[x y] (.pop stack) pos (Pos x y)] (when (and (>= x 0) (>= y 0) (< x (+/size (+/at! expanded 0))) (< y (+/size expanded)) (not (get-at-pos checked pos))) (set-at-pos checked pos true) (when (+/is "." (get-at-pos expanded pos)) (set-at-pos enclosed (Pos (+/floor (/ x 3)) (+/floor (/ y 3))) false) (.push stack [x (+ y 1)]) (.push stack [x (- y 1)]) (.push stack [(+ x 1) y]) (.push stack [(- x 1) y])))) (recur stack)))))
(defn part2 [input] (let [[m initial] (parse-input input) h (+/size m) w (+/size (+/at! m 0)) expanded (init-matrix (* 3 w) (* 3 h) ".") checked (init-matrix (* 3 w) (* 3 h) false) enclosed (init-matrix w h true)] (loop [inst (step initial)] (set-at-pos enclosed (inst-pos inst) false) (inflate (inst-pos inst) m expanded) (when (not (start? inst)) (recur (step inst)))) (fill-unenclosed expanded checked enclosed (Pos 0 0)) (+/reduce (fn [_anon%1_43 _anon%2_44] (+/reduce (fn [acc b] (+ acc (if b 1 0))) _anon%1_43 _anon%2_44)) 0 enclosed)))
(defn inspectGrid [input] (let [m (+/fmap (fn [_anon%1_45] (lib/strsplit _anon%1_45 "")) (lib/strsplit input "\n"))] (loop [i 0] (when (< i (+/size m)) (loop [j 0] (when (< j (+/size (+/at! m i))) (if (+/is "S" (+/at! (+/at! m i) j)) (do (+/log "I" i "J" j) (+/log (+/str " " (+/at! (+/at! m (- i 1)) j))) (+/log (+/str (+/at! (+/at! m i) (- j 1)) "?" (+/at! (+/at! m i) (+ j 1)))) (+/log (+/str " " (+/at! (+/at! m (+ i 1)) j)))) (recur (+ 1 j))))) (recur (+ 1 i))))))
