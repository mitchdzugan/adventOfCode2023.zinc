(require ' ["./lib.mjs" :as lib])
(require ' ["./../+.mjs" :as + :refer-macros true])
(do nil (def DirT 34))
(def Left [34 3])
(def Right [34 4])
(def Up [34 1])
(def Down [34 2])
(defn init-dir [c] (cond (+/is c "-") Left (+/is c "7") Up (+/is c "|") Up (+/is c "J") Down (+/is c "L") Down (+/is c "F") Up))
(defn next-dir [c dir] (cond (+/is c "-") (let [val-1 dir spec-2 {3 (fn [] (let [] Left)), 4 (fn [] (let [] Right))}] ((or (aget spec-2 (aget val-1 1)) (aget spec-2 0)))) (+/is c "7") (let [val-3 dir spec-4 {1 (fn [] (let [] Left)), 4 (fn [] (let [] Down))}] ((or (aget spec-4 (aget val-3 1)) (aget spec-4 0)))) (+/is c "|") (let [val-5 dir spec-6 {1 (fn [] (let [] Up)), 2 (fn [] (let [] Down))}] ((or (aget spec-6 (aget val-5 1)) (aget spec-6 0)))) (+/is c "J") (let [val-7 dir spec-8 {2 (fn [] (let [] Left)), 4 (fn [] (let [] Up))}] ((or (aget spec-8 (aget val-7 1)) (aget spec-8 0)))) (+/is c "L") (let [val-9 dir spec-10 {2 (fn [] (let [] Right)), 3 (fn [] (let [] Up))}] ((or (aget spec-10 (aget val-9 1)) (aget spec-10 0)))) (+/is c "F") (let [val-11 dir spec-12 {1 (fn [] (let [] Right)), 3 (fn [] (let [] Down))}] ((or (aget spec-12 (aget val-11 1)) (aget spec-12 0))))))
(do nil (def PosT 33))
(defn Pos [x y] [33 x y])
(defn eq-pos [p1 p2] (let [^{:unname "x"} var-x-13 (aget p1 1) ^{:unname "y"} var-y-14 (aget p1 2)] (let [^{:unname "x"} var-x-15 (aget p2 1) ^{:unname "y"} var-y-16 (aget p2 2)] (and (= ^{:unname "x"} var-x-13 ^{:unname "x"} var-x-15) (= ^{:unname "y"} var-y-14 ^{:unname "y"} var-y-16)))))
(defn get-at-pos [m val-17 s-char] (let [^{:unname "y"} var-y-18 (aget val-17 2) ^{:unname "x"} var-x-19 (aget val-17 1)] (let [res (+/or "." (+/at (+/or (+/Vec) (+/at m ^{:unname "y"} var-y-18)) ^{:unname "x"} var-x-19))] (if (+/is res "S") s-char res))))
(defn set-at-pos [m val-20 v] (let [^{:unname "y"} var-y-21 (aget val-20 2) ^{:unname "x"} var-x-22 (aget val-20 1)] (+/put (+/at! m ^{:unname "y"} var-y-21) ^{:unname "x"} var-x-22 v)))
(defn step-pos [val-23 dir] (let [^{:unname "x"} var-x-24 (aget val-23 1) ^{:unname "y"} var-y-25 (aget val-23 2)] (let [x ^{:unname "x"} var-x-24 y ^{:unname "y"} var-y-25] (let [val-26 dir spec-27 {3 (fn [] (let [] (Pos (- x 1) y))), 4 (fn [] (let [] (Pos (+ x 1) y))), 1 (fn [] (let [] (Pos x (- y 1)))), 2 (fn [] (let [] (Pos x (+ y 1))))}] ((or (aget spec-27 (aget val-26 1)) (aget spec-27 0)))))))
(do nil (def InstT 35))
(defn Inst [m pos dir origin s-char] [35 m pos dir origin s-char])
(defn inst-pos [val-28] (let [^{:unname "pos"} var-pos-29 (aget val-28 2)] ^{:unname "pos"} var-pos-29))
(defn step [val-30] (let [^{:unname "m"} var-m-31 (aget val-30 1) ^{:unname "pos"} var-pos-32 (aget val-30 2) ^{:unname "s-char"} var-s-char-33 (aget val-30 5) ^{:unname "dir"} var-dir-34 (aget val-30 3) ^{:unname "origin"} var-origin-35 (aget val-30 4)] (let [ndir (next-dir (get-at-pos ^{:unname "m"} var-m-31 ^{:unname "pos"} var-pos-32 ^{:unname "s-char"} var-s-char-33) ^{:unname "dir"} var-dir-34)] (Inst ^{:unname "m"} var-m-31 (step-pos ^{:unname "pos"} var-pos-32 ndir) ndir ^{:unname "origin"} var-origin-35 ^{:unname "s-char"} var-s-char-33))))
(defn start? [val-36] (let [^{:unname "pos"} var-pos-37 (aget val-36 2) ^{:unname "origin"} var-origin-38 (aget val-36 4)] (eq-pos ^{:unname "pos"} var-pos-37 ^{:unname "origin"} var-origin-38)))
(defn get-initial-pos [m] (->> (+/bind (fn [r y] (+/fmap (fn [c x] [c x y]) r)) m) (+/fmap (fn [[c x y]] (if (= "S" c) (+/Just (Pos x y)) +/None))) (+/bind +/vals) (+/first!)))
(defn make-loop-only-assuming [base s-char] (let [loop-only (+/fmap (fn [_anon%1_4] (+/fmap (fn [] ".") _anon%1_4)) base) init-pos (get-initial-pos base) mk-inst (fn [_anon%1_5] (Inst _anon%1_5 init-pos (init-dir s-char) init-pos s-char))] (loop [inst (step (mk-inst base))] (let [p (inst-pos inst)] (set-at-pos loop-only p (get-at-pos base p s-char))) (if (start? inst) (step inst) (recur (step inst)))) loop-only))
(defn try-s-char [base s-char] (try (+/Just (make-loop-only-assuming base s-char)) (catch js/Object e +/None)))
(defn make-loop-only [base] (-> (fn [_anon%1_7 _anon%2_6] (+/or- (fn [] (try-s-char base _anon%2_6)) (+/fmap +/Just _anon%1_7))) (+/reduce +/None (+/Vec "-" "|" "J" "L" "F" "7")) (+/unwrap!)))
(defn to-matrix [input] (+/fmap (fn [_anon%1_8] (lib/strsplit _anon%1_8 "")) (lib/strsplit input "\n")))
(let [parse-into-matrix-with-loop-only-impl-3 (fn [input] (make-loop-only (to-matrix input))) parse-into-matrix-with-loop-only-memo-5 (+/Map)] (defn parse-into-matrix-with-loop-only [& parse-into-matrix-with-loop-only-args-4] (let [parse-into-matrix-with-loop-only-mkey-2 (+/encode (+/fmap +/forcedKey (+/apply +/Vec parse-into-matrix-with-loop-only-args-4))) parse-into-matrix-with-loop-only-rtrn-1 (+/or- (fn [] (+/apply parse-into-matrix-with-loop-only-impl-3 parse-into-matrix-with-loop-only-args-4)) (+/at parse-into-matrix-with-loop-only-memo-5 parse-into-matrix-with-loop-only-mkey-2))] (+/put parse-into-matrix-with-loop-only-memo-5 parse-into-matrix-with-loop-only-mkey-2 parse-into-matrix-with-loop-only-rtrn-1) parse-into-matrix-with-loop-only-rtrn-1)))
(defn part1 [input] (let [m (parse-into-matrix-with-loop-only input)] (->> (+/bind +/id m) (+/remove (fn [_anon%1_9] (+/is "." _anon%1_9))) ((fn [p] (+/floor (/ (+/size p) 2)))))))
(let [crossings-to-top-edge-impl-8 (fn [m x y] (let [getc (fn [_anon%1_10] (get-at-pos m (Pos x _anon%1_10))) plain? (fn [_anon%1_11] (+/is (getc _anon%1_11) ".")) edge? (fn [_anon%1_12] (or (+/is (getc _anon%1_12) "-") (+/is (getc _anon%1_12) "|"))) get-rest (fn [_anon%1_13] (crossings-to-top-edge m x (- _anon%1_13 1)))] (cond (< y 0) 0 (plain? y) (get-rest y) (edge? y) (+ 1 (get-rest y)) :else (loop [suby (- y 1)] (if (edge? suby) (recur (- suby 1)) (+ (get-rest suby) (if (= (next-dir (getc y) Down) (next-dir (getc suby) Up)) 0 1))))))) crossings-to-top-edge-memo-10 (+/Map)] (defn crossings-to-top-edge [& crossings-to-top-edge-args-9] (let [crossings-to-top-edge-mkey-7 (+/encode (+/fmap +/forcedKey (+/apply +/Vec crossings-to-top-edge-args-9))) crossings-to-top-edge-rtrn-6 (+/or- (fn [] (+/apply crossings-to-top-edge-impl-8 crossings-to-top-edge-args-9)) (+/at crossings-to-top-edge-memo-10 crossings-to-top-edge-mkey-7))] (+/put crossings-to-top-edge-memo-10 crossings-to-top-edge-mkey-7 crossings-to-top-edge-rtrn-6) crossings-to-top-edge-rtrn-6)))
(defn enclosed? [m val-39] (let [^{:unname "x"} var-x-40 (aget val-39 1) ^{:unname "y"} var-y-41 (aget val-39 2)] (and (= "." (get-at-pos m val-39)) (= 1 (+/mod (crossings-to-top-edge m ^{:unname "x"} var-x-40 ^{:unname "y"} var-y-41) 2)))))
(defn part2 [input] (let [m (parse-into-matrix-with-loop-only input)] (->> (+/fmap (fn [row y] (+/filter (fn [_anon%1_15 _anon%2_14] (enclosed? m (Pos _anon%2_14 y))) row)) m) (+/reduce (fn [_anon%1_16 _anon%2_17] (+ _anon%1_16 (+/size _anon%2_17))) 0))))
