(require ' ["./lib.mjs" :as lib])
(require ' ["./../+.mjs" :as + :refer-macros true])
(do nil (def DirT 34))
(def Left [34 3])
(def Right [34 4])
(def Up [34 1])
(def Down [34 2])
(defn init-dir [c] (cond (+/is c "-") Left (+/is c "7") Up (+/is c "|") Up (+/is c "J") Down (+/is c "L") Down (+/is c "F") Up))
(defn next-dir [c dir] (cond (+/is c "-") (let [val-107 dir spec-108 {3 (fn [] (let [] Left)), 4 (fn [] (let [] Right))}] ((or (aget spec-108 (aget val-107 1)) (aget spec-108 0)))) (+/is c "7") (let [val-109 dir spec-110 {1 (fn [] (let [] Left)), 4 (fn [] (let [] Down))}] ((or (aget spec-110 (aget val-109 1)) (aget spec-110 0)))) (+/is c "|") (let [val-111 dir spec-112 {1 (fn [] (let [] Up)), 2 (fn [] (let [] Down))}] ((or (aget spec-112 (aget val-111 1)) (aget spec-112 0)))) (+/is c "J") (let [val-113 dir spec-114 {2 (fn [] (let [] Left)), 4 (fn [] (let [] Up))}] ((or (aget spec-114 (aget val-113 1)) (aget spec-114 0)))) (+/is c "L") (let [val-115 dir spec-116 {2 (fn [] (let [] Right)), 3 (fn [] (let [] Up))}] ((or (aget spec-116 (aget val-115 1)) (aget spec-116 0)))) (+/is c "F") (let [val-117 dir spec-118 {1 (fn [] (let [] Right)), 3 (fn [] (let [] Down))}] ((or (aget spec-118 (aget val-117 1)) (aget spec-118 0))))))
(do nil (def PosT 33))
(defn Pos [x y] [33 x y])
(defn eq-pos [p1 p2] (let [^{:unname "x"} var-x-119 (aget p1 1) ^{:unname "y"} var-y-120 (aget p1 2)] (let [^{:unname "x"} var-x-121 (aget p2 1) ^{:unname "y"} var-y-122 (aget p2 2)] (and (= ^{:unname "x"} var-x-119 ^{:unname "x"} var-x-121) (= ^{:unname "y"} var-y-120 ^{:unname "y"} var-y-122)))))
(defn get-at-pos [m val-123 s-char] (let [^{:unname "y"} var-y-124 (aget val-123 2) ^{:unname "x"} var-x-125 (aget val-123 1)] (let [res (+/or "." (+/at (+/or (+/Vec) (+/at m ^{:unname "y"} var-y-124)) ^{:unname "x"} var-x-125))] (if (+/is res "S") s-char res))))
(defn set-at-pos [m val-126 v] (let [^{:unname "y"} var-y-127 (aget val-126 2) ^{:unname "x"} var-x-128 (aget val-126 1)] (+/put (+/at! m ^{:unname "y"} var-y-127) ^{:unname "x"} var-x-128 v)))
(defn step-pos [val-129 dir] (let [^{:unname "x"} var-x-130 (aget val-129 1) ^{:unname "y"} var-y-131 (aget val-129 2)] (let [x ^{:unname "x"} var-x-130 y ^{:unname "y"} var-y-131] (let [val-132 dir spec-133 {3 (fn [] (let [] (Pos (- x 1) y))), 4 (fn [] (let [] (Pos (+ x 1) y))), 1 (fn [] (let [] (Pos x (- y 1)))), 2 (fn [] (let [] (Pos x (+ y 1))))}] ((or (aget spec-133 (aget val-132 1)) (aget spec-133 0)))))))
(do nil (def InstT 35))
(defn Inst [m pos dir origin s-char] [35 m pos dir origin s-char])
(defn inst-pos [val-134] (let [^{:unname "pos"} var-pos-135 (aget val-134 2)] ^{:unname "pos"} var-pos-135))
(defn step [val-136] (let [^{:unname "m"} var-m-137 (aget val-136 1) ^{:unname "pos"} var-pos-138 (aget val-136 2) ^{:unname "s-char"} var-s-char-139 (aget val-136 5) ^{:unname "dir"} var-dir-140 (aget val-136 3) ^{:unname "origin"} var-origin-141 (aget val-136 4)] (let [ndir (next-dir (get-at-pos ^{:unname "m"} var-m-137 ^{:unname "pos"} var-pos-138 ^{:unname "s-char"} var-s-char-139) ^{:unname "dir"} var-dir-140)] (Inst ^{:unname "m"} var-m-137 (step-pos ^{:unname "pos"} var-pos-138 ndir) ndir ^{:unname "origin"} var-origin-141 ^{:unname "s-char"} var-s-char-139))))
(defn start? [val-142] (let [^{:unname "pos"} var-pos-143 (aget val-142 2) ^{:unname "origin"} var-origin-144 (aget val-142 4)] (eq-pos ^{:unname "pos"} var-pos-143 ^{:unname "origin"} var-origin-144)))
(defn get-initial-pos [m] (->> (+/bind (fn [r y] (+/fmap (fn [c x] [c x y]) r)) m) (+/fmap (fn [[c x y]] (if (= "S" c) (+/Just (Pos x y)) +/None))) (+/bind +/vals) (+/first!)))
(defn make-loop-only-assuming [base s-char] (let [loop-only (+/fmap (fn [_anon%1_20] (+/fmap (fn [] ".") _anon%1_20)) base) init-pos (get-initial-pos base) mk-inst (fn [_anon%1_21] (Inst _anon%1_21 init-pos (init-dir s-char) init-pos s-char))] (loop [inst (step (mk-inst base))] (let [p (inst-pos inst)] (set-at-pos loop-only p (get-at-pos base p s-char))) (if (start? inst) (step inst) (recur (step inst)))) loop-only))
(defn try-s-char [base s-char] (try (+/Just (make-loop-only-assuming base s-char)) (catch js/Object e +/None)))
(defn make-loop-only [base] (-> (fn [_anon%1_23 _anon%2_22] (+/or- (fn [] (try-s-char base _anon%2_22)) (+/fmap +/Just _anon%1_23))) (+/reduce +/None (+/Vec "-" "|" "J" "L" "F" "7")) (+/unwrap!)))
(defn to-matrix [input] (+/fmap (fn [_anon%1_24] (lib/strsplit _anon%1_24 "")) (lib/strsplit input "\n")))
(let [parse-into-matrix-with-loop-only-impl-28 (fn [input] (make-loop-only (to-matrix input))) parse-into-matrix-with-loop-only-memo-30 (+/Map)] (defn parse-into-matrix-with-loop-only [& parse-into-matrix-with-loop-only-args-29] (let [parse-into-matrix-with-loop-only-mkey-27 (+/encode (+/fmap +/forcedKey (+/apply +/Vec parse-into-matrix-with-loop-only-args-29))) parse-into-matrix-with-loop-only-rtrn-26 (+/or- (fn [] (+/apply parse-into-matrix-with-loop-only-impl-28 parse-into-matrix-with-loop-only-args-29)) (+/at parse-into-matrix-with-loop-only-memo-30 parse-into-matrix-with-loop-only-mkey-27))] (+/put parse-into-matrix-with-loop-only-memo-30 parse-into-matrix-with-loop-only-mkey-27 parse-into-matrix-with-loop-only-rtrn-26) parse-into-matrix-with-loop-only-rtrn-26)))
(defn part1 [input] (let [m (parse-into-matrix-with-loop-only input)] (->> (+/bind +/id m) (+/remove (fn [_anon%1_25] (+/is "." _anon%1_25))) ((fn [p] (+/floor (/ (+/size p) 2)))))))
(let [crossings-to-top-edge-impl-33 (fn [m x y] (let [getc (fn [_anon%1_26] (get-at-pos m (Pos x _anon%1_26))) plain? (fn [_anon%1_27] (+/is (getc _anon%1_27) ".")) edge? (fn [_anon%1_28] (or (+/is (getc _anon%1_28) "-") (+/is (getc _anon%1_28) "|"))) corner? (fn [_anon%1_29] (and (not (edge? _anon%1_29)) (not (plain? (getc _anon%1_29))))) get-rest (fn [_anon%1_30] (crossings-to-top-edge m x (- _anon%1_30 1)))] (cond (< y 0) 0 (plain? y) (get-rest y) (edge? y) (+ 1 (get-rest y)) :else (loop [suby (- y 1)] (if (edge? suby) (recur (- suby 1)) (+ (get-rest suby) (if (= (next-dir (getc y) Down) (next-dir (getc suby) Up)) 0 1))))))) crossings-to-top-edge-memo-35 (+/Map)] (defn crossings-to-top-edge [& crossings-to-top-edge-args-34] (let [crossings-to-top-edge-mkey-32 (+/encode (+/fmap +/forcedKey (+/apply +/Vec crossings-to-top-edge-args-34))) crossings-to-top-edge-rtrn-31 (+/or- (fn [] (+/apply crossings-to-top-edge-impl-33 crossings-to-top-edge-args-34)) (+/at crossings-to-top-edge-memo-35 crossings-to-top-edge-mkey-32))] (+/put crossings-to-top-edge-memo-35 crossings-to-top-edge-mkey-32 crossings-to-top-edge-rtrn-31) crossings-to-top-edge-rtrn-31)))
(defn enclosed? [m val-145] (let [^{:unname "x"} var-x-146 (aget val-145 1) ^{:unname "y"} var-y-147 (aget val-145 2)] (and (= "." (get-at-pos m val-145)) (= 1 (+/mod (crossings-to-top-edge m ^{:unname "x"} var-x-146 ^{:unname "y"} var-y-147) 2)))))
(defn part2 [input] (let [m (parse-into-matrix-with-loop-only input)] (->> (+/fmap (fn [row y] (+/filter (fn [_anon%1_32 _anon%2_31] (enclosed? m (Pos _anon%2_31 y))) row)) m) (+/reduce (fn [_anon%1_33 _anon%2_34] (+ _anon%1_33 (+/size _anon%2_34))) 0))))
