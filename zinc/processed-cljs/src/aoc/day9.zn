(require ' ["./lib.mjs" :as lib])
(require ' ["./../+.mjs" :as + :refer-macros true])
(defn zeros? [history] (+/every? (fn [_anon%1_20] (+/is 0 _anon%1_20)) history))
(defn next-value [history] (->> (let [next (+/Vec)] (+/push seqs next) (loop [ind 1] (when (< ind (+/size curr)) (+/push next (- (+/at! curr ind) (+/at! curr (- ind 1)))) (recur (+ ind 1)))) (recur (+ depth 1))) (if (zeros? curr) (do (+/push curr 0) (loop [depth depth] (if (<= depth 0) (+/last! history) (let [curr (+/at! seqs depth) prev (+/at! seqs (- depth 1))] (+/push prev (+ (+/last! prev) (+/last! curr))) (recur (- depth 1))))))) (let [curr (+/at! seqs depth)]) (loop [depth 0]) (let [seqs (+/Vec history)])))
(defn process [input reverse?] (->> (lib/strsplit input "\n") (+/filter (fn [_anon%1_21] (not (+/is "" (.trim _anon%1_21))))) (+/fmap (fn [_anon%1_22] (lib/strsplit (.trim _anon%1_22) lib/rx_whitespace))) (+/fmap (fn [_anon%1_23] (+/fmap lib/parseInt _anon%1_23))) (+/fmap (if reverse? +/reverse +/id)) (+/fmap next-value) (+/reduce (fn [_anon%1_24 _anon%2_25] (+ _anon%1_24 _anon%2_25)) 0)))
(defn part1 [input] (process input false))
(defn part2 [input] (process input true))
