(require ' ["./lib.mjs" :as lib])
(require ' ["./../+.mjs" :as + :refer-macros true])
(def IGNORE_LEADING_0 false)
(def digitStrs (+/Map [["one" 1] ["two" 2] ["three" 3] ["four" 4] ["five" 5] ["six" 6] ["seven" 7] ["eight" 8] ["nine" 9] ["ten" 10]]))
(def digitStrLengths ((fn [] (let [seenLengths (+/Map)] (+/each (fn [_anon%1_2 _anon%2_1] (+/put seenLengths (.-length _anon%2_1) true)) digitStrs) (+/sort (+/keys seenLengths))))))
(defn getDigit [src index useDigitStrs exclude0] (let [digit (js/parseInt (.substr src index 1) 10)] (if (and (< digit 10) (>= digit (if exclude0 1 0))) (+/Just digit) (loop [result +/None strLenIndex 0] (if (or (not useDigitStrs) (not (+/empty? result)) (> strLenIndex (+/size digitStrLengths))) result (let [strLen (+/or 0 (+/at digitStrLengths strLenIndex)) substr (.substr src index strLen)] (recur (+/at digitStrs substr) (+ strLenIndex 1))))))))
(do (do (aset +/qt-store 17 "OriginT") (+/bury +/prop-store [17 1] {0 {:idname "+", :fullname "%+", :ind 0}}) (+/bury +/prop-store [17 2] {0 {:idname "+", :fullname "%+", :ind 0}}) (+/bury +/variant-store [17 1] "Front") (+/bury +/variant-store [17 2] "Back")) (def OriginT 17))
(def Front [17 1])
(def Back [17 2])
(defn firstDigit [src origin useDigitStrs] (let [start (let [val-1 origin spec-2 {1 (fn [] (let [] 0)), 2 (fn [] (let [] (- (.-length src) 1)))}] ((or (aget spec-2 (aget val-1 1)) (aget spec-2 0)))) delta (let [val-3 origin spec-4 {1 (fn [] (let [] 1)), 2 (fn [] (let [] -1))}] ((or (aget spec-4 (aget val-3 1)) (aget spec-4 0)))) exclude0 (let [val-5 origin spec-6 {1 (fn [] (let [] IGNORE_LEADING_0)), 2 (fn [] (let [] false))}] ((or (aget spec-6 (aget val-5 1)) (aget spec-6 0))))] (loop [result +/None index start] (if (or (not (+/empty? result)) (>= index (.-length src)) (< index 0)) result (recur (getDigit src index useDigitStrs exclude0) (+ index delta))))))
(defn getCalibrationValue [src useDigitStrs] (->> (+/Just (+ (* 10 dTens) dOnes)) (fn [dOnes]) ((fn [_anon%1_6 _anon%2_5] (+/bind _anon%2_5 _anon%1_6)) (firstDigit src Back useDigitStrs)) (fn [dTens]) ((fn [_anon%1_4 _anon%2_3] (+/bind _anon%2_3 _anon%1_4)) (firstDigit src Front useDigitStrs))))
(defn getCalibrationSum [input useDigitStrs] (->> (lib/strsplit input "\n") (+/fmap (fn [_anon%1_7] (getCalibrationValue _anon%1_7 useDigitStrs))) (+/reduce (fn [_anon%1_8 _anon%2_9] (+ _anon%1_8 (+/or 0 _anon%2_9))) 0)))
(defn part1 [input] (getCalibrationSum input false))
(defn part2 [input] (getCalibrationSum input true))
(defn solve [] (let [input (lib/getInput 1)] (lib/Solution (part1 input) (part2 input))))
