(require ' ["./lib.mjs" :as lib])
(require ' ["./../+.mjs" :as + :refer-macros true])
(do (do (aset +/qt-store 18 "CubeNumsT") (+/bury +/prop-store [18 nil] {0 {:idname "red", :fullname "%red", :ind 0, :type +/NumT}, 1 {:idname "green", :fullname "%green", :ind 1, :type +/NumT}, 2 {:idname "blue", :fullname "%blue", :ind 2, :type +/NumT}})) (def CubeNumsT 18))
(defn CubeNums [red green blue] [18 red green blue])
(do (do (aset +/qt-store 22 "SchemaNumberT") (+/bury +/prop-store [22 nil] {0 {:idname "value", :fullname "%value", :ind 0}, 1 {:idname "part-number?", :fullname "%part-number?", :ind 1}})) (def SchemaNumberT 22))
(defn SchemaNumber [value] [22 value false])
(defn value [val-1] (let [^{:unname "value"} var-value-2 (aget val-1 1)] ^{:unname "value"} var-value-2))
(defn part-number? [val-3] (let [^{:unname "part-number?"} var-part-number?-4 (aget val-3 2)] ^{:unname "part-number?"} var-part-number?-4))
(defn accept-part-number [schema-number] [22 (value schema-number) true])
(do (do (aset +/qt-store 19 "GameT") (+/bury +/prop-store [19 nil] {0 {:idname "id", :fullname "%id", :ind 0}, 1 {:idname "rounds", :fullname "%rounds", :ind 1, :type [+/VecT CubeNumsT]}})) (def GameT 19))
(do (do (aset +/qt-store 20 "TokenT") (+/bury +/prop-store [20 1] {0 {:idname "+", :fullname "%+", :ind 0}, 1 {:idname "d", :fullname "%d", :ind 1}}) (+/bury +/prop-store [20 2] {0 {:idname "+", :fullname "%+", :ind 0}, 1 {:idname "s", :fullname "%s", :ind 1}}) (+/bury +/prop-store [20 3] {0 {:idname "+", :fullname "%+", :ind 0}}) (+/bury +/variant-store [20 1] "Digit") (+/bury +/variant-store [20 2] "Symbol") (+/bury +/variant-store [20 3] "Dot")) (def TokenT 20))
(defn Digit [d] [20 1 d])
(defn Symbol [s] [20 2 s])
(def Dot [20 3])
(defn classify [c] (if (+/is c ".") Dot (let [d (js/parseInt c 10)] (if (and (>= d 0) (< d 10)) (Digit d) (Symbol c)))))
(defn put-in [v2d i j v] (let [row (+/or (+/Vec) (+/at v2d i))] (+/put row j v)))
(defn process-grid [input handle-symbol-neighbors] (let [token-grid (->> (lib/strsplit input "\n") (+/fmap (fn [_anon%1_1] (+/fmap classify (lib/strsplit _anon%1_1 ""))))) schema-number-id-grid (+/fmap (fn [_anon%1_2] (+/fmap (fn [] +/None) _anon%1_2)) token-grid) schema-numbers (+/Vec) add-neighbor (fn [neighbors i j] (->> (+/put neighbors schema-number-id schema-number) (fn [schema-number]) ((fn [_anon%1_10 _anon%2_9] (+/bind _anon%2_9 _anon%1_10)) (+/at schema-numbers schema-number-id)) (fn [schema-number-id]) ((fn [_anon%1_8 _anon%2_7] (+/bind _anon%2_7 _anon%1_8)) mschema-number-id) (fn [mschema-number-id]) ((fn [_anon%1_6 _anon%2_5] (+/bind _anon%2_5 _anon%1_6)) (+/at row j)) (fn [row]) ((fn [_anon%1_4 _anon%2_3] (+/bind _anon%2_3 _anon%1_4)) (+/at schema-number-id-grid i)))) init-schema-number (fn [_anon%1_11] (when (> _anon%1_11 0) (+/put schema-numbers (+/size schema-numbers) (SchemaNumber _anon%1_11))))] (-> (fn [row i] (let [ending (-> (fn [acc val-5 j] (let [val-6 val-5 spec-7 {1 (fn [] (let [^{:unname "d"} var-d-8 (aget val-6 2)] (let [next (+ (* 10 acc) ^{:unname "d"} var-d-8)] (->> (+/Just (+/size schema-numbers)) (put-in schema-number-id-grid i j) (when (> next 0))) next))), 0 (fn [] (let [] (do (init-schema-number acc) 0)))}] ((or (aget spec-7 (aget val-6 1)) (aget spec-7 0))))) (+/reduce 0 row))] (init-schema-number ending))) (+/each token-grid)) (-> (fn [row i] (-> (fn [val-9 j] (let [val-10 val-9 spec-11 {2 (fn [] (let [] (let [neighbors (+/Map)] (add-neighbor neighbors (+/dec i) (+/dec j)) (add-neighbor neighbors (+/dec i) (+/id j)) (add-neighbor neighbors (+/dec i) (+/inc j)) (add-neighbor neighbors (+/id i) (+/dec j)) (add-neighbor neighbors (+/id i) (+/inc j)) (add-neighbor neighbors (+/inc i) (+/dec j)) (add-neighbor neighbors (+/inc i) (+/id j)) (add-neighbor neighbors (+/inc i) (+/inc j)) (handle-symbol-neighbors neighbors schema-numbers)))), 0 (fn [] (let [] nil))}] ((or (aget spec-11 (aget val-10 1)) (aget spec-11 0))))) (+/each row))) (+/each token-grid)) schema-numbers))
(defn part1 [input] (->> (->> (+/each (fn [_anon%1_13 _anon%2_12] (+/put schema-nums _anon%2_12 (accept-part-number _anon%1_13))) neighbors) (fn [neighbors schema-nums]) (process-grid input)) (+/filter part-number?) (+/fmap value) (+/reduce (fn [_anon%1_14 _anon%2_15] (+ _anon%1_14 _anon%2_15)) 0)))
(defn part2 [input] (let [gear-ratio-sum-ref [0] get-gear-ratio-sum (fn [] (aget gear-ratio-sum-ref 0)) add-gear-ratio (fn [_anon%1_16] (aset gear-ratio-sum-ref 0 (+ (get-gear-ratio-sum) _anon%1_16)))] (->> (add-gear-ratio (+/reduce (fn [_anon%1_17 _anon%2_18] (* _anon%1_17 (value _anon%2_18))) 1 neighbors)) (when (+/is 2 (+/size neighbors))) (fn [neighbors]) (process-grid input)) (get-gear-ratio-sum)))
(defn solve [] (let [input (lib/getInput 3)] (lib/Solution (part1 input) (part2 input))))
