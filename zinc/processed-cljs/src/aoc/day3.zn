(require ' ["./lib.mjs" :as lib])
(require ' ["./../+.mjs" :as + :refer-macros true])
(do nil (def SchemaNumberT 16))
(defn SchemaNumber [value] [16 value false])
(defn value [val-48] (let [^{:unname "value"} var-value-49 (aget val-48 1)] ^{:unname "value"} var-value-49))
(defn part-number? [val-50] (let [^{:unname "part-number?"} var-part-number?-51 (aget val-50 2)] ^{:unname "part-number?"} var-part-number?-51))
(defn accept-part-number [schema-number] [16 (value schema-number) true])
(do nil (def TokenT 17))
(defn Digit [d] [17 1 d])
(defn Symbol [s] [17 2 s])
(def Dot [17 3])
(defn classify [c] (->> (if (and (>= d 0) (< d 10)) (Digit d) (Symbol c)) (let [d (lib/parseInt c)]) (if (+/is c ".") Dot)))
(defn put-in [v2d i j v] (let [row (+/or (+/Vec) (+/at v2d i))] (+/put row j v)))
(defn process-grid [input handle-symbol-neighbors] (let [token-grid (->> (lib/strsplit input "\n") (+/fmap (fn [_anon%1_35] (+/fmap classify (lib/strsplit _anon%1_35 ""))))) schema-number-id-grid (+/fmap (fn [_anon%1_36] (+/fmap (fn [] +/None) _anon%1_36)) token-grid) schema-numbers (+/Vec) init-schema-number (fn [_anon%1_37] (->> (SchemaNumber _anon%1_37) (+/put schema-numbers (+/size schema-numbers)) (when (> _anon%1_37 0)))) add-neighbor (fn [neighbors i j] (->> (+/put neighbors schema-number-id schema-number) (fn [schema-number]) ((fn [_anon%1_45 _anon%2_44] (+/bind _anon%2_44 _anon%1_45)) (+/at schema-numbers schema-number-id)) (fn [schema-number-id]) ((fn [_anon%1_43 _anon%2_42] (+/bind _anon%2_42 _anon%1_43)) mschema-number-id) (fn [mschema-number-id]) ((fn [_anon%1_41 _anon%2_40] (+/bind _anon%2_40 _anon%1_41)) (+/at row j)) (fn [row]) ((fn [_anon%1_39 _anon%2_38] (+/bind _anon%2_38 _anon%1_39)) (+/at schema-number-id-grid i))))] (-> (fn [row i] (-> (fn [acc val-52 j] (let [val-53 val-52 spec-54 {1 (fn [] (let [^{:unname "d"} var-d-55 (aget val-53 2)] (let [next (+ (* 10 acc) ^{:unname "d"} var-d-55)] (->> (+/Just (+/size schema-numbers)) (put-in schema-number-id-grid i j) (when (> next 0))) next))), 0 (fn [] (let [] (do (init-schema-number acc) 0)))}] ((or (aget spec-54 (aget val-53 1)) (aget spec-54 0))))) (+/reduce 0 row) (init-schema-number))) (+/each token-grid)) (-> (fn [row i] (-> (fn [val-56 j] (let [val-57 val-56 spec-58 {2 (fn [] (let [] (let [neighbors (+/Map)] (add-neighbor neighbors (+/dec i) (+/dec j)) (add-neighbor neighbors (+/dec i) (+/id j)) (add-neighbor neighbors (+/dec i) (+/inc j)) (add-neighbor neighbors (+/id i) (+/dec j)) (add-neighbor neighbors (+/id i) (+/inc j)) (add-neighbor neighbors (+/inc i) (+/dec j)) (add-neighbor neighbors (+/inc i) (+/id j)) (add-neighbor neighbors (+/inc i) (+/inc j)) (handle-symbol-neighbors neighbors schema-numbers)))), 0 (fn [] (let []))}] ((or (aget spec-58 (aget val-57 1)) (aget spec-58 0))))) (+/each row))) (+/each token-grid)) schema-numbers))
(defn part1 [input] (->> (->> (+/each (fn [_anon%1_47 _anon%2_46] (+/put schema-nums _anon%2_46 (accept-part-number _anon%1_47))) neighbors) (fn [neighbors schema-nums]) (process-grid input)) (+/filter part-number?) (+/fmap value) (+/reduce (fn [_anon%1_48 _anon%2_49] (+ _anon%1_48 _anon%2_49)) 0)))
(defn part2 [input] (let [sum-ref (aref 0)] (->> (+/reduce (fn [_anon%1_50 _anon%2_51] (* _anon%1_50 (value _anon%2_51))) 1 neighbors) (+ (aget sum-ref "r")) (a= sum-ref) (when (+/is 2 (+/size neighbors))) (fn [neighbors]) (process-grid input)) (aget sum-ref "r")))
