(require ' ["./lib.mjs" :as lib])
(require ' ["./../+.mjs" :as + :refer-macros true])
(do nil (def HandTypeT 27))
(defn type-val [val-148] (let [val-149 val-148 spec-150 {1 (fn [] (let [] 6)), 2 (fn [] (let [] 5)), 6 (fn [] (let [] 4)), 3 (fn [] (let [] 3)), 7 (fn [] (let [] 2)), 4 (fn [] (let [] 1)), 5 (fn [] (let [] 0))}] ((or (aget spec-150 (aget val-149 1)) (aget spec-150 0)))))
(def Kind5 [27 1])
(def Kind4 [27 2])
(def FullHouse [27 6])
(def Kind3 [27 3])
(def TwoPair [27 7])
(def Kind2 [27 4])
(def Kind1 [27 5])
(defn card-val [c jokers?] (cond (+/is c "2") 1 (+/is c "3") 2 (+/is c "4") 3 (+/is c "5") 4 (+/is c "6") 5 (+/is c "7") 6 (+/is c "8") 7 (+/is c "9") 8 (+/is c "T") 9 (+/is c "J") (if jokers? 0 10) (+/is c "Q") 11 (+/is c "K") 12 (+/is c "A") 13 :else 0))
(defn joker? [c] (+/is c "J"))
(defn get-type [cards jokers?] (let [card-counts (+/Map) rpairs (aref 0) rjokers (aref 0) rkind (aref 0)] (+/for cards (fn [_anon%1_9] (let [card-count (+ 1 (+/or 0 (+/at card-counts _anon%1_9)))] (when (or (not jokers?) (not (joker? _anon%1_9))) (a= rkind (js/Math.max (aget rkind "r") card-count))) (when (joker? _anon%1_9) (a#= rjokers +/inc)) (when (+/is card-count 2) (a#= rpairs +/inc)) (+/put card-counts _anon%1_9 card-count)))) (let [kind (+ (aget rkind "r") (if jokers? (aget rjokers "r") 0)) pairs? (> (aget rpairs "r") 1)] (cond (and (+/is kind 5) true) Kind5 (and (+/is kind 4) true) Kind4 (and (+/is kind 3) pairs?) FullHouse (and (+/is kind 3) true) Kind3 (and (+/is kind 2) pairs?) TwoPair (and (+/is kind 2) true) Kind2 (and (+/is kind 1) true) Kind1))))
(defn get-val [cards jokers?] (->> (+/fmap (fn [_anon%1_10] (card-val _anon%1_10 jokers?)) cards) (+/reduce (fn [_anon%1_11 _anon%2_13 _anon%3_12] (+ _anon%1_11 (* (js/Math.pow 14 (- (+/size cards) 1 _anon%3_12)) _anon%2_13))) 0)))
(do nil (def HandStatsT 28))
(defn hand-val [val-151] (let [^{:unname "val"} var-val-152 (aget val-151 2)] ^{:unname "val"} var-val-152))
(defn hand-bid [val-153] (let [^{:unname "bid"} var-bid-154 (aget val-153 3)] ^{:unname "bid"} var-bid-154))
(defn hand-type-val [val-155] (let [^{:unname "type"} var-type-156 (aget val-155 1)] (type-val ^{:unname "type"} var-type-156)))
(defn parse-line [line jokers?] (let [[cardsstr bidstr] (.split (.trim line) lib/rx_whitespace) cards (lib/strsplit cardsstr "") type (get-type cards jokers?) val (get-val cards jokers?) bid (lib/parseInt bidstr)] [28 type val bid]))
(defn sort-hands [hands] (let [by-type-val (+/groupBy hand-type-val hands)] (-> (fn [_anon%1_14] (+/sort-by hand-val (+/or (+/Vec) (+/at by-type-val (type-val _anon%1_14))))) (+/bind (+/Vec Kind1 Kind2 TwoPair Kind3 FullHouse Kind4 Kind5)))))
(defn get-total-winnings [input jokers?] (->> (lib/strsplit input "\n") (+/filter (fn [_anon%1_15] (not (+/is "" (.trim _anon%1_15))))) (+/fmap (fn [_anon%1_16] (parse-line _anon%1_16 jokers?))) (sort-hands) (+/reduce (fn [_anon%1_17 _anon%2_19 _anon%3_18] (+ _anon%1_17 (* (+ 1 _anon%3_18) (hand-bid _anon%2_19)))) 0)))
(defn part1 [input] (get-total-winnings input false))
(defn part2 [input] (get-total-winnings input true))
