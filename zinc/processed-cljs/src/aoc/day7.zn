(require ' ["./lib.mjs" :as lib])
(require ' ["./../+.mjs" :as + :refer-macros true])
(do nil (def HandTypeT 27))
(defn type-val [val-145] (let [val-146 val-145 spec-147 {1 (fn [] (let [] 6)), 2 (fn [] (let [] 5)), 6 (fn [] (let [] 4)), 3 (fn [] (let [] 3)), 7 (fn [] (let [] 2)), 4 (fn [] (let [] 1)), 5 (fn [] (let [] 0))}] ((or (aget spec-147 (aget val-146 1)) (aget spec-147 0)))))
(def Kind5 [27 1])
(def Kind4 [27 2])
(def FullHouse [27 6])
(def Kind3 [27 3])
(def TwoPair [27 7])
(def Kind2 [27 4])
(def Kind1 [27 5])
(defn card-val [c jokers?] (cond (+/is c "2") 1 (+/is c "3") 2 (+/is c "4") 3 (+/is c "5") 4 (+/is c "6") 5 (+/is c "7") 6 (+/is c "8") 7 (+/is c "9") 8 (+/is c "T") 9 (+/is c "J") (if jokers? 0 10) (+/is c "Q") 11 (+/is c "K") 12 (+/is c "A") 13 :else 0))
(defn joker? [c] (+/is c "J"))
(defn get-type [cards jokers?] (let [card-counts (+/Map) rpairs (aref 0) rjokers (aref 0) rkind (aref 0)] (+/for cards (fn [_anon%1_31] (let [card-count (+ 1 (+/or 0 (+/at card-counts _anon%1_31)))] (when (or (not jokers?) (not (joker? _anon%1_31))) (a= rkind (js/Math.max (aget rkind "r") card-count))) (when (joker? _anon%1_31) (a#= rjokers +/inc)) (when (+/is card-count 2) (a#= rpairs +/inc)) (+/put card-counts _anon%1_31 card-count)))) (let [kind (+ (aget rkind "r") (if jokers? (aget rjokers "r") 0)) pairs? (> (aget rpairs "r") 1)] (cond (and (+/is kind 5) true) Kind5 (and (+/is kind 4) true) Kind4 (and (+/is kind 3) pairs?) FullHouse (and (+/is kind 3) true) Kind3 (and (+/is kind 2) pairs?) TwoPair (and (+/is kind 2) true) Kind2 (and (+/is kind 1) true) Kind1))))
(defn get-val [cards jokers?] (->> (+/fmap (fn [_anon%1_32] (card-val _anon%1_32 jokers?)) cards) (+/reduce (fn [_anon%1_33 _anon%2_35 _anon%3_34] (+ _anon%1_33 (* (js/Math.pow 14 (- (+/size cards) 1 _anon%3_34)) _anon%2_35))) 0)))
(do nil (def HandStatsT 28))
(defn hand-val [val-148] (let [^{:unname "val"} var-val-149 (aget val-148 2)] ^{:unname "val"} var-val-149))
(defn hand-bid [val-150] (let [^{:unname "bid"} var-bid-151 (aget val-150 3)] ^{:unname "bid"} var-bid-151))
(defn hand-type-val [val-152] (let [^{:unname "type"} var-type-153 (aget val-152 1)] (type-val ^{:unname "type"} var-type-153)))
(defn parse-line [line jokers?] (let [[cardsstr bidstr] (.split (.trim line) lib/rx_whitespace) cards (lib/strsplit cardsstr "") type (get-type cards jokers?) val (get-val cards jokers?) bid (lib/parseInt bidstr)] [28 type val bid]))
(defn sort-hands [hands] (let [by-type-val (+/groupBy hand-type-val hands)] (-> (fn [_anon%1_36] (+/sort-by hand-val (+/or (+/Vec) (+/at by-type-val (type-val _anon%1_36))))) (+/bind (+/Vec Kind1 Kind2 TwoPair Kind3 FullHouse Kind4 Kind5)))))
(defn get-total-winnings [input jokers?] (->> (lib/strsplit input "\n") (+/filter (fn [_anon%1_37] (not (+/is "" (.trim _anon%1_37))))) (+/fmap (fn [_anon%1_38] (parse-line _anon%1_38 jokers?))) (sort-hands) (+/reduce (fn [_anon%1_39 _anon%2_41 _anon%3_40] (+ _anon%1_39 (* (+ 1 _anon%3_40) (hand-bid _anon%2_41)))) 0)))
(defn part1 [input] (get-total-winnings input false))
(defn part2 [input] (get-total-winnings input true))
