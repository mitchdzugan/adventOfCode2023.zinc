(require ' ["./lib.mjs" :as lib])
(require ' ["./../+.mjs" :as + :refer-macros true])
(defn gcd [a_ b_] (loop [a a_ b b_] (if (+/is 0 b) a (recur b (+/mod a b)))))
(defn lcm [a_ b_] (let [a (+/max a_ b_) b (+/min a_ b_)] (* (/ a (gcd a b)) b)))
(do nil (def DirectionT 19))
(def Left [19 1])
(def Right [19 2])
(defn left? [val-53] (let [val-54 val-53 spec-55 {1 (fn [] (let [] true)), 0 (fn [] (let [] false))}] ((or (aget spec-55 (aget val-54 1)) (aget spec-55 0)))))
(do nil (def NodeT 20))
(defn Node [id left right] [20 id left right])
(defn left [val-56] (let [^{:unname "left"} var-left-57 (aget val-56 2)] ^{:unname "left"} var-left-57))
(defn right [val-58] (let [^{:unname "right"} var-right-59 (aget val-58 3)] ^{:unname "right"} var-right-59))
(defn nodeId [val-60] (let [^{:unname "id"} var-id-61 (aget val-60 1)] ^{:unname "id"} var-id-61))
(defn parseLine [line] (let [[idstr neighbors] (.split line "=") id (.trim idstr) left (-> neighbors (.split ",") (aget 0) (.split "(") (aget 1) .trim) right (-> neighbors (.split ",") (aget 1) (.split ")") (aget 0) .trim)] (Node id left right)))
(defn parseNav [line] (->> (lib/strsplit line "") (+/bind (fn [_anon%1_61] (cond (= _anon%1_61 "L") (+/Vec Left) (= _anon%1_61 "R") (+/Vec Right) :else (+/Vec))))))
(do nil (def NavInputT 21))
(defn NavInput [nav nodes] [21 nav nodes])
(defn parseInput [input] (let [lines (lib/strsplit input "\n") navLine (+/at! lines 0) nav (parseNav navLine) nodes (->> (+/filter (fn [_anon%1_62] (.includes _anon%1_62 "=")) lines) (+/fmap parseLine) (+/keyBy (fn [val-62] (let [^{:unname "id"} var-id-63 (aget val-62 1)] ^{:unname "id"} var-id-63))))] (NavInput nav nodes)))
(defn step [val-64 steps id] (let [^{:unname "nodes"} var-nodes-65 (aget val-64 2) ^{:unname "nav"} var-nav-66 (aget val-64 1)] (let [node (+/at! ^{:unname "nodes"} var-nodes-65 id) dir (+/at! ^{:unname "nav"} var-nav-66 (+/mod steps (+/size ^{:unname "nav"} var-nav-66)))] ((if (left? dir) left right) node))))
(defn part1 [input] (-> (parseInput input) ((fn [val-67] (let [] (loop [steps 0 id "AAA"] (if (= id "ZZZ") steps (recur (+ steps 1) (step val-67 steps id)))))))))
(do nil (def PatternT 32))
(defn Pattern [initLength loopLength inits loops] [32 initLength loopLength inits loops])
(def NullPattern (Pattern 0 0 (+/Vec) (+/Vec)))
(defn nullPattern? [val-68] (let [^{:unname "initLength"} var-initLength-69 (aget val-68 1) ^{:unname "loopLength"} var-loopLength-70 (aget val-68 2)] (+/is 0 (+ ^{:unname "initLength"} var-initLength-69 ^{:unname "loopLength"} var-loopLength-70))))
(defn in-pattern? [val-71 target] (let [^{:unname "initLength"} var-initLength-72 (aget val-71 1) ^{:unname "loopLength"} var-loopLength-73 (aget val-71 2) ^{:unname "inits"} var-inits-74 (aget val-71 3) ^{:unname "loops"} var-loops-75 (aget val-71 4)] (let [offsetTarget (+/mod (- target ^{:unname "initLength"} var-initLength-72) ^{:unname "loopLength"} var-loopLength-73) isTarget? (fn [v] (+/is target v)) isOffsetTarget? (fn [v] (+/is offsetTarget v))] (if (< target ^{:unname "initLength"} var-initLength-72) (+/any? isTarget? ^{:unname "inits"} var-inits-74) (+/any? isOffsetTarget? ^{:unname "loops"} var-loops-75)))))
(defn gen-until [val-76 stepCap_ genCap_] (let [^{:unname "initLength"} var-initLength-77 (aget val-76 1) ^{:unname "loopLength"} var-loopLength-78 (aget val-76 2) ^{:unname "inits"} var-inits-79 (aget val-76 3) ^{:unname "loops"} var-loops-80 (aget val-76 4)] (let [stepCap (or stepCap_ 0) genCap (or genCap_ 0) res (+/Vec) loopStart (fn [i] (+ ^{:unname "initLength"} var-initLength-77 (* i ^{:unname "loopLength"} var-loopLength-78))) validStep? (fn [v] (or (+/is 0 stepCap) (< v stepCap))) canGen? (fn [] (or (+/is 0 genCap) (< (+/size res) genCap))) canPush? (fn [v] (and (validStep? v) (canGen?))) push (fn [v] (when (canPush? v) (+/push res v))) pushLoop (fn [i] (fn [v] (push (+ (loopStart i) v)))) validIter? (fn [i] (validStep? (loopStart i)))] (+/for ^{:unname "inits"} var-inits-79 push) (loop [i 0] (if (and (canGen?) (validIter? i)) (do (+/for ^{:unname "loops"} var-loops-80 (pushLoop i)) (recur (+ i 1))) res)))))
(defn merge [p1 p2] (cond (nullPattern? p1) p2 (nullPattern? p2) p1 :else (let [^{:unname "initLength"} var-initLength-81 (aget p1 1) ^{:unname "loopLength"} var-loopLength-82 (aget p1 2)] (let [^{:unname "initLength"} var-initLength-83 (aget p2 1) ^{:unname "loopLength"} var-loopLength-84 (aget p2 2)] (let [initLength (+/max ^{:unname "initLength"} var-initLength-81 ^{:unname "initLength"} var-initLength-83) loopLength (lcm ^{:unname "loopLength"} var-loopLength-82 ^{:unname "loopLength"} var-loopLength-84) inits (+/Vec) loops (+/Vec) total (+ initLength loopLength)] (+/for (gen-until p1 total) (fn [v] (when (in-pattern? p2 v) (if (< v initLength) (+/push inits v) (+/push loops (- v initLength)))))) (Pattern initLength loopLength inits loops))))))
(defn fill-pattern [val-85 startId initLength totalLength] (let [] (let [loopLength (- totalLength initLength) inits (+/Vec) loops (+/Vec)] (loop [steps 0 id startId] (let [loop? (>= steps initLength) done? (>= steps (+ initLength loopLength))] (if done? (Pattern initLength loopLength inits loops) (do (when (.endsWith id "Z") (+/push (if loop? loops inits) (if loop? (- steps initLength) steps))) (recur (+ steps 1) (step val-85 steps id)))))))))
(defn find-pattern [val-86 startId] (let [^{:unname "nav"} var-nav-87 (aget val-86 1)] (let [seen (+/Map)] (loop [steps 0 id startId] (let [navPos (+/mod steps (+/size ^{:unname "nav"} var-nav-87)) pos (+/str id "." navPos)] (if (+/has? seen pos) (fill-pattern val-86 startId (+/at! seen pos) steps) (do (+/put seen pos steps) (recur (+ steps 1) (step val-86 steps id)))))))))
(defn part2 [input] (-> (parseInput input) ((fn [val-88] (let [^{:unname "nodes"} var-nodes-89 (aget val-88 2)] (->> (+/fmap nodeId (+/vals ^{:unname "nodes"} var-nodes-89)) (+/filter (fn [id] (.endsWith id "A"))) (+/fmap (fn [id] (find-pattern val-88 id))) (+/reduce (fn [acc p] (merge acc p)) NullPattern))))) (gen-until 0 1)))
