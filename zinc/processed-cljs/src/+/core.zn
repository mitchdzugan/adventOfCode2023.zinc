(require ' ["./types.mjs" :as + :exporting "*"])
(def- key-impls {})
(defn implement-key [type-id f] (aset key-impls type-id f))
(defn key [obj] ((aget key-impls (type-id obj)) obj))
(defn forcedKey [obj] ((or (aget key-impls (type-id obj)) inst-id) obj))
(implement-key +/NumT +/id)
(implement-key +/StrT +/id)
(implement-key +/BoolT +/id)
(+/implement-monad-plus +/NumT (fn [] (-> 0)) (fn [_anon%1_71 _anon%2_72] (+ _anon%1_71 _anon%2_72)))
(+/implement-monad-plus +/StrT (fn [] (-> "")) +/str)
(+/implement-monad-plus +/BoolT (fn [] (-> false)) (fn [_anon%1_73 _anon%2_74] (clojure.core/or _anon%1_73 _anon%2_74)))
(+/implement-monad-plus +/VecT (fn [] (Vec)) (fn [_anon%1_75 _anon%2_76] (concat _anon%1_75 _anon%2_76)))
(+/implement-monad-plus +/MaybeT (fn [] (-> None)) (fn [_anon%1_78 _anon%2_77] (maybe _anon%2_77 Just _anon%1_78)))
(+/implement-applicative +/VecT (fn [_anon%1_79] (Vec _anon%1_79)))
(+/implement-applicative +/MaybeT (fn [_anon%1_80] (Just _anon%1_80)))
(+/implement-flatplicative-for-applicative +/VecT)
(+/implement-flatplicative-for-applicative +/MaybeT)
(+/implement-flatplicative +/StrT +/str)
(+/implement-flatplicative +/BoolT (fn [_anon%1_81] (+/not (+/not _anon%1_81))))
(def MapClass +/MapClass)
(def Unit [+/UnitT])
(defn Vec [& a-] (let [a (clojure.core/or a- []) id (+/mk-inst-id)] {:T +/VecT, :I id, :J ^{:get true} (cljs.core/this-as $-7 (+/apply +/argv +/VecT (.map a json))), :P ^{:get true} (cljs.core/this-as $-8 (.map a pretty)), :a a}))
(defn Map [pairs] (new MapClass pairs))
(defn Set [& initials-] (let [initials (clojure.core/or initials- []) d (Map) id (+/mk-inst-id)] (.forEach initials (fn [_anon%1_82] (.set d (key _anon%1_82) _anon%1_82))) {:T +/SetT, :I id, :J ^{:get true} (cljs.core/this-as $-9 (+/js-array-from d [+/SetT] (fn [[_ v]] (json v)))), :P ^{:get true} (cljs.core/this-as $-10 (pretty (vals d))), :d d}))
(defn KeyMap [pairs] (let [ks (Map (.map pairs (fn [[k]] [(key k) k]))) vs (Map (.map pairs (fn [[k v]] [(key k) v]))) id (+/mk-inst-id)] {:T +/KeyMapT, :I id, :J ^{:get true} (cljs.core/this-as $-11 (+/js-array-from vs [+/KeyMapT] (fn [[kk v]] [(json (.get ks kk)) (json v)]))), :P ^{:get true} (cljs.core/this-as $-12 (pretty vs)), :ks ks, :vs vs}))
(defn KeyedList [pairs] (let [id (+/mk-inst-id) kl {:I id, :P ^{:get true} (cljs.core/this-as $-13 (->> (fn [[id v]] [(+/str "#" id) (pretty v)]) (+/js-flat-array-from (.-a $-13) ["#:KeyedList"]))), :J ^{:get true} (cljs.core/this-as $-14 (->> (fn [[id v]] [id (json v)]) (+/js-array-from (.-a $-14) [+/KeyedListT]))), :T +/KeyedListT, :l nil, :d {}, :f nil, :i 1, :a ^{:get true} (cljs.core/this-as $-15 (let [res []] (loop [id (.-f $-15)] (if (+/nil? id) res (let [[v pid nid] (aget $-15 "d" id)] (.push res [id v]) (recur nid))))))} empty? (fn [_anon%1_83] (+/is 0 (+/js-length _anon%1_83)))] (doto kl (do (when-not (empty? pairs) (aset kl "f" (aget pairs 0 0)) (loop [[[nid nv :as next] & rest] pairs [cid cv :as curr] [] [pid pv :as prev] [] max-id 0] (when-not (+/nil? cid) (aset kl "d" cid [cv pid nid])) (if (not (empty? rest)) (recur rest next curr (+/max max-id nid)) (doto kl (aset "i" (inc max-id)) (aset "l" nid) (aset "d" nid [nv cid])))))))))
(defn- mkMaybe [j e] (let [id (+/mk-inst-id)] {:T +/MaybeT, :I id, :J ^{:get true} (cljs.core/this-as $-16 (if e [+/MaybeT +/null] [+/MaybeT (json j)])), :P ^{:get true} (cljs.core/this-as $-17 (if e +/null {:just (pretty j)})), :j j, :e e}))
(defn Just [j] (mkMaybe j false))
(def None (mkMaybe nil true))
(defn Maybe [nilable] (mkMaybe nilable (+/nil? nilable)))
(defn type-id [any] (.-T any))
(defn inst-id [any] (.-I any))
(defn json [any] (.-J any))
(defn pretty [any] (and any (.-P any)))
(defn- coll-impl [spec obj] ((clojure.core/or (aget spec (type-id obj)) (aget spec +/else))))
(defn Range [& args] (let [[a1 a2 a3] args fin (fn [init end step] (+/apply Vec (js/Array.from (js/Array (+/ceil (+/div (- end init) step))) (fn [_anon%1_85 _anon%2_84] (+ init (* step _anon%2_84))))))] (cond (+/nil? a1) (Vec) (+/nil? a2) (fin 0 a1 (if (>= a1 0) 1 -1)) (+/nil? a3) (fin a1 a2 (if (>= a2 a1) 1 -1)) :else (fin a1 a2 a3))))
(defn at ([val-1 k] (let [$ val-1] (coll-impl {[+/VecT] (fn [] (Maybe (aget $ "a" k))), [+/MapT] (fn [] (Maybe (.get $ k))), [+/SetT] (fn [] (fmap (fn [] Unit) (Maybe (.get (.-d $) (key k))))), [+/KeyMapT] (fn [] (Maybe ((.. $ -vs -get) (key k)))), [+/KeyedListT] (fn [] (fmap (fn [_anon%1_86] (aget _anon%1_86 0)) (Maybe (aget $ "d" k)))), [+/MaybeT] (fn [] (if (or (not= 0 k) (.-e $)) None $))} $))))
(defn has? [c k] (not (empty? (at c k))))
(defn intersection [s1 s2] (+/apply Set (.-a (filter (fn [_anon%1_87] (has? s2 _anon%1_87)) (vals s1)))))
(defn union [s1 s2] (+/apply Set (.-a (concat (vals s1) (vals s2)))))
(defn put ([val-2 k v] (let [$ val-2] (coll-impl {[+/VecT] (fn [] (aset $ "a" k v)), [+/MapT] (fn [] (.set $ k v)), [+/KeyMapT] (fn [] (let [kk (key k)] (.set (.-ks $) kk k) (.set (.-vs $) kk v))), [+/KeyedListT] (fn [] "TODO")} $))))
(defn for-each-map [f m get-js-m map-key] (.forEach (+/js-array-from (get-js-m m) (fn [[k v]] (fn [] (f v (map-key k) m)))) (fn [_anon%1_88] (_anon%1_88))))
(defn each ([f val-3] (let [$ val-3] (coll-impl {[+/VecT] (fn [] ((.. $ -a -forEach) (fn [_anon%1_89 _anon%2_90] (f _anon%1_89 _anon%2_90 $)))), [+/MapT] (fn [] (for-each-map f $ +/id +/id)), [+/KeyMapT] (fn [] (for-each-map f $ (fn [_anon%1_91] (.-vs _anon%1_91)) (fn [_anon%1_92] ((.. $ -ks -get) _anon%1_92)))), [+/MaybeT] (fn [] (when-not (.-e $) (f (.-j $) 0 $))), [+/KeyedListT] (fn [] ((.. $ -a forEach (fn [[id v] ind] (f v id $ ind)))))} $))))
(defn reduce [f init coll] (let [res [init]] (each (fn [_anon%1_93 _anon%2_94 _anon%3_95 _anon%4_96] (aset res 0 (f (aget res 0) _anon%1_93 _anon%2_94 _anon%3_95 _anon%4_96))) coll) (aget res 0)))
(defn fmap ([f val-4] (let [$ val-4] (coll-impl {[+/VecT] (fn [] (+/apply Vec ((.. $ -a -map) (fn [_anon%1_97 _anon%2_98] (f _anon%1_97 _anon%2_98 $))))), [+/MapT] (fn [] (Map (+/js-array-from $ (fn [[k v]] [k (f v k $)])))), [+/MaybeT] (fn [] (if (.-e $) $ (Just (f (.-j $) 0 $))))} $))))
(defn bind ([f val-5] (let [$ val-5] (coll-impl {[+/VecT] (fn [] (+/apply Vec ((.. $ -a -flatMap) (fn [_anon%1_99 _anon%2_100] (.-a (f _anon%1_99 _anon%2_100 $)))))), [+/MaybeT] (fn [] (if (.-e $) $ (f (.-j $) 0 $)))} $))))
(defn concat [...args] (bind +/id (+/apply Vec args)))
(defn filter ([p val-6] (let [$ val-6] (coll-impl {[+/VecT] (fn [] (+/apply Vec ((.. $ -a -filter) (fn [_anon%1_101 _anon%2_102] (p _anon%1_101 _anon%2_102 $))))), [+/MaybeT] (fn [] (if (clojure.core/or (.-e $) (p (.-j $) 0 $)) $ None))} $))))
(defn remove [p coll] (filter (fn [_anon%1_103 _anon%2_104 _anon%3_105] (+/not (p _anon%1_103 _anon%2_104 _anon%3_105))) coll))
(defn keys ([val-7] (let [$ val-7] (coll-impl {[+/VecT] (fn [] (Range (+/js-length (.-a $)))), [+/MapT] (fn [] (+/apply Vec (+/js-array-from $ (fn [_anon%1_106] (aget _anon%1_106 0))))), [+/SetT] (fn [] (vals (.-d $))), [+/KeyMapT] (fn [] (vals (.-ks $))), [+/MaybeT] (fn [] (if (.-e $) (Vec) (Vec 0)))} $))))
(defn vals ([val-8] (let [$ val-8] (coll-impl {[+/VecT] (fn [] (+/apply Vec (.-a $))), [+/MapT] (fn [] (+/apply Vec (+/js-array-from $ (fn [_anon%1_107] (aget _anon%1_107 1))))), [+/SetT] (fn [] (vals (.-d $))), [+/KeyMapT] (fn [] (vals (.-vs $))), [+/MaybeT] (fn [] (if (.-e $) (Vec) (Vec (.-j $))))} $))))
(defn size ([val-9] (let [$ val-9] (coll-impl {[+/VecT] (fn [] (+/js-length (.-a $))), [+/MapT] (fn [] (.. $ -size)), [+/SetT] (fn [] (size (vals (.-d $)))), [+/KeyMapT] (fn [] (size (.-ks $))), [+/MaybeT] (fn [] (if (.-e $) 0 1))} $))))
(defn or- ([mk-default-val val-10] (let [$ val-10] (coll-impl {[+/MaybeT] (fn [] (if (.-e $) (mk-default-val) (.-j $)))} $))))
(defn or [default-val m] (or- (fn [] default-val) m))
(defn unwrap! [m] (or- (fn [] (throw "unwrap forced on 'None' type")) m))
(defn at! [c id] (unwrap! (at c id)))
(defn maybe- ([on-none on-just val-11] (let [$ val-11] (coll-impl {[+/MaybeT] (fn [] (if (.-e $) (on-none) (on-just (.-j $))))} $))))
(defn maybe [none on-just m] (maybe- (fn [] none) on-just m))
(defn insert ([val-12 target-id v] (let [$ val-12] (coll-impl {[+/VecT] (fn [] (if (>= target-id (size $)) None (do (.splice $ target-id 0 v) (Just target-id)))), [+/MapT] (fn [] (fmap (fn [] (do (put $ target-id v) target-id)) (at $ target-id))), [+/KeyMapT] (fn [] (let [kk (key target-id)] (fmap (fn [] (do (put (.-ks $) kk v) (put (.-vs $) kk v) kk)) (at (.-ks $) kk)))), [+/KeyedListT] (fn [] (let [id (aget $ "i") prepend (aget $ "d" target-id)] (if (nil? prepend) None (let [[pid] (aget prepend 1)] (doto $ (amod "n" inc) ((if (+/nil? pid) (fn [_anon%1_108] (aset _anon%1_108 "f" pid)) (fn [_anon%1_109] (aset _anon%1_109 "d" pid 2 id)))) (aset _anon%1_110 "d" target-id 1 id) (aset _anon%1_110 "d" id [v pid target-id])) (Just id)))))} $))))
(defn push ([val-13 v] (let [$ val-13] (coll-impl {[+/VecT] (fn [] (.push (.-a $) v)), [+/SetT] (fn [] (.set (.-d $) (key v) v)), [+/KeyedListT] (fn [] "TODO")} $))))
(defn unshift ([val-14 v] (let [$ val-14] (coll-impl {[+/VecT] (fn [] (.unshift (.-a $) v)), [+/SetT] (fn [] (.set (.-d $) (key v) v)), [+/KeyedListT] (fn [] (insert $ (.-f $) v))} $))))
(defn sort-by ([f val-15] (let [$ val-15] (coll-impl {[+/VecT] (fn [] (let [res (+/apply Vec (.-a $))] (.sort (.-a res) (fn [_anon%1_111 _anon%2_112] (- (f _anon%1_111) (f _anon%2_112)))) res))} $))))
(defn sort [c] (sort-by +/id c))
(defn keyBy [f c] (let [res (Map)] (each (fn [_anon%1_113] (put res (f _anon%1_113) _anon%1_113)) c) res))
(defn empty? [c] (+/is 0 (size c)))
(defn unjson [v] (let [unjson-pairs (fn [[k v]] [(unjson k) (unjson v)])] (cond (+/js-array? v) ((-> {[+/MaybeT] (fn [] (fmap unjson (Maybe (aget v 1)))), [+/VecT] (fn [] (fmap unjson (+/apply Vec (.slice v 1)))), [+/MapT] (fn [] (Map (.map unjson-pairs (.slice v 1)))), [+/KeyMapT] (fn [] (KeyMap (.map unjson-pairs (.slice v 1))))} (aget (type-id v)) (or (fn [] (.map v unjson))))) (aget {[+/StrT] true, [+/NumT] true, [+/BoolT] true} (and v (type-id v))) v :else (throw (+/str "Val: /" v "/ is of unsupported type")))))
(defn encode [v] (js/JSON.stringify (json v)))
(defn decode [s] (unjson (js/JSON.parse s)))
