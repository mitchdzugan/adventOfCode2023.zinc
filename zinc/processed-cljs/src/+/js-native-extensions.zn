(require ' ["./core.mjs" :as +])
(defn- def-property [js-class k impl] (when-not ((.. js-class -prototype -hasOwnProperty) k) (.defineProperty js/Object (.-prototype js-class) k {:get (fn [] (this-as this ((.bind impl this))))})))
(defn- def-method [js-class k impl] (aset (.-prototype js-class) k impl))
(defn- defs-for [js-class f] (f (fn [k impl] (def-property js-class k impl)) (fn [k impl] (def-method js-class k impl))))
(defs-for js/Number (fn [def-property def-method] (def-property "T" (fn [] (cljs.core/this-as $-184 +/NumT))) (doseq [k ["J" "P" "I"]] (def-property k (fn [] (cljs.core/this-as $-185 (.valueOf $-185)))))))
(defs-for js/Boolean (fn [def-property def-method] (def-property "T" (fn [] (cljs.core/this-as $-186 +/BoolT))) (doseq [k ["J" "P" "I"]] (def-property k (fn [] (cljs.core/this-as $-187 (.valueOf $-187)))))))
(defs-for js/String (fn [def-property def-method] (def-property "T" (fn [] (cljs.core/this-as $-188 +/StrT))) (doseq [k ["J" "P" "I"]] (def-property k (fn [] (cljs.core/this-as $-189 (.valueOf $-189)))))))
(defs-for js/Map (fn [def-property def-method] (def-property "T" (fn [] (cljs.core/this-as $-190 +/MapT))) (def-property "I" (fn [] (cljs.core/this-as $-191 (let [i (or (aget $-191 "i") (+/mk-inst-id))] (aset $-191 "i" i) i)))) (def-property "J" (fn [] (cljs.core/this-as $-192 (+/js-array-from $-192 [+/MapT] (fn [_anon%1_156] (.map _anon%1_156 +/json)))))) (def-property "P" (fn [] (cljs.core/this-as $-193 (let [res {}] (.forEach (+/js-array-from $-193) (fn [_anon%1_157] (let [k (aget _anon%1_157 0) pk (if (+/js-str? k) (+/str "\"" k "\"") k) pv (+/pretty (aget _anon%1_157 1))] (aset res pk pv)))) res))))))
(defs-for js/Array (fn [def-property def-method] (def-property "T" (fn [] (cljs.core/this-as $-194 (aget $-194 0)))) (def-property "I" (fn [] (cljs.core/this-as $-195 (let [i (or (aget $-195 "i") (+/mk-inst-id))] (aset $-195 "i" i) i)))) (def-property "J" (fn [] (cljs.core/this-as $-196 (.map $-196 +/json)))) (def-property "P" (fn [] (cljs.core/this-as $-197 (let [id (.-T $-197) res {}] (aset res "Type" (or (aget +/qt-store id) id)) (.forEach (.slice $-197 1) (fn [v ind] (let [pk (or (+/dig +/prop-store [id nil ind :idname]) (+/dig +/prop-store [id (aget $-197 1) ind :idname]) ind)] (if (+/is pk "+") (aset res "Type" (+/str (aget res "Type") "[" (+/dig +/variant-store [id (aget $-197 1)]) "]")) (aset res pk (+/pretty v)))))) res))))))
