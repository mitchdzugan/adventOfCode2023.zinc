(require ' ["./raw-js.mjs" :as + :exporting "*"])
(defn mk-id-generator [] (let [next-id [1]] (fn [] (amod next-id 0 +/inc) (+/dec (aget next-id 0)))))
(def mk-inst-id (mk-id-generator))
(def qt-store {})
(defn set-qt-store [id display-name] (aset qt-store id display-name) id)
(def prop-store {})
(def variant-store {})
(def monad-plus-impls {})
(defn implement-monad-plus [type-id mzero-impl mplus-impl] (aset monad-plus-impls type-id [mzero-impl mplus-impl]))
(defn mzero [type-id] ((aget monad-plus-impls type-id 0)))
(defn mplus [a b] ((aget monad-plus-impls (.-T a) 1) a b))
(def applicative-impls {})
(defn implement-applicative [type-id pure-impl] (aset applicative-impls type-id pure-impl))
(defn pure [type-id a] ((aget applicative-impls type-id) a))
(def flatplicative-impls {})
(defn implement-flatplicative [type-id ensure-type-impl] (aset flatplicative-impls type-id ensure-type-impl))
(defn implement-flatplicative-for-applicative [type-id] (implement-flatplicative type-id (fn [_anon%1_114] (if (= type-id (.-T _anon%1_114)) _anon%1_114 (pure type-id _anon%1_114)))))
(defn ensure-type [type-id obj] ((aget flatplicative-impls type-id) obj))
(defn fplus [type-id a b] (let [b-flat (when b (ensure-type type-id b))] (cond (+/nil? a) b-flat (+/nil? b) a :else (mplus a b-flat))))
