{:merge-state {:defreferred nil, :refer-macros {"/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" "+"}, :name-alias nil, :placeholders nil, :get-dep-path {"lib" "/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn", "+" "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn"}, :get-as-alias {"/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn" "lib", "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" "+"}, :exporting nil, :runtime-deps {"/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn" true, "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" true}}, :res {:code [(require ' ["./lib.mjs" :as lib]) (require ' ["./../+.mjs" :as + :refer-macros true]) (defn zeros? [history] (+/every? (fn [_anon%1_23] (+/is 0 _anon%1_23)) history)) (defn next-value [history] (<<- (let [seqs (+/Vec history)]) (loop [depth 0]) (let [curr (+/at! seqs depth)]) (if (zeros? curr) (do (+/push curr 0) (loop [depth depth] (if (<= depth 0) (+/last! history) (let [curr (+/at! seqs depth) prev (+/at! seqs (- depth 1))] (+/push prev (+ (+/last! prev) (+/last! curr))) (recur (- depth 1))))))) (let [next (+/Vec)] (+/push seqs next) (loop [ind 1] (when (< ind (+/size curr)) (+/push next (- (+/at! curr ind) (+/at! curr (- ind 1)))) (recur (+ ind 1)))) (recur (+ depth 1))))) (defn process [input reverse?] (->> (lib/strsplit input "\n") (+/filter (fn [_anon%1_24] (not (+/is "" (.trim _anon%1_24))))) (+/fmap (fn [_anon%1_25] (lib/strsplit (.trim _anon%1_25) lib/rx_whitespace))) (+/fmap (fn [_anon%1_26] (+/fmap lib/parseInt _anon%1_26))) (+/fmap (if reverse? +/reverse +/id)) (+/fmap next-value) (+/reduce (fn [_anon%1_27 _anon%2_28] (+ _anon%1_27 _anon%2_28)) 0))) (defn part1 [input] (process input false)) (defn part2 [input] (process input true))], :preprocessing nil}}