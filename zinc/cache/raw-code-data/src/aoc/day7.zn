{:merge-state {:defreferred nil, :refer-macros {"/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" "+"}, :name-alias nil, :placeholders nil, :get-dep-path {"lib" "/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn", "+" "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn"}, :get-as-alias {"/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn" "lib", "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" "+"}, :exporting nil, :runtime-deps {"/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn" true, "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" true}}, :res {:code [(require ' ["./lib.mjs" :as lib]) (require ' ["./../+.mjs" :as + :refer-macros true]) (def+ HandTypeT (Kind5) (Kind4) (Kind3) (Kind2) (Kind1) (FullHouse) (TwoPair)) (defn-impl type-val [HandTypeT] (Kind5 6) (Kind4 5) (FullHouse 4) (Kind3 3) (TwoPair 2) (Kind2 1) (Kind1 0)) (def Kind5 (mk (Kind5 of HandTypeT))) (def Kind4 (mk (Kind4 of HandTypeT))) (def FullHouse (mk (FullHouse of HandTypeT))) (def Kind3 (mk (Kind3 of HandTypeT))) (def TwoPair (mk (TwoPair of HandTypeT))) (def Kind2 (mk (Kind2 of HandTypeT))) (def Kind1 (mk (Kind1 of HandTypeT))) (defn card-val [c jokers?] (cond (+/is c "2") 1 (+/is c "3") 2 (+/is c "4") 3 (+/is c "5") 4 (+/is c "6") 5 (+/is c "7") 6 (+/is c "8") 7 (+/is c "9") 8 (+/is c "T") 9 (+/is c "J") (if jokers? 0 10) (+/is c "Q") 11 (+/is c "K") 12 (+/is c "A") 13 :else 0)) (defn joker? [c] (+/is c "J")) (defn get-type [cards jokers?] (let [card-counts (+/Map) rpairs (aref 0) rjokers (aref 0) rkind (aref 0)] (+/for cards (fn [_anon%1_17] (let [card-count (+ 1 (+/or 0 (+/at card-counts _anon%1_17)))] (when (or (not jokers?) (not (joker? _anon%1_17))) (a= rkind (js/Math.max (aget rkind "r") card-count))) (when (joker? _anon%1_17) (a#= rjokers +/inc)) (when (+/is card-count 2) (a#= rpairs +/inc)) (+/put card-counts _anon%1_17 card-count)))) (let [kind (+ (aget rkind "r") (if jokers? (aget rjokers "r") 0)) pairs? (> (aget rpairs "r") 1)] (cond (and (+/is kind 5) true) Kind5 (and (+/is kind 4) true) Kind4 (and (+/is kind 3) pairs?) FullHouse (and (+/is kind 3) true) Kind3 (and (+/is kind 2) pairs?) TwoPair (and (+/is kind 2) true) Kind2 (and (+/is kind 1) true) Kind1)))) (defn get-val [cards jokers?] (->> (+/fmap (fn [_anon%1_18] (card-val _anon%1_18 jokers?)) cards) (+/reduce (fn [_anon%1_19 _anon%2_21 _anon%3_20] (+ _anon%1_19 (* (js/Math.pow 14 (- (+/size cards) 1 _anon%3_20)) _anon%2_21))) 0))) (def* HandStatsT [type val bid]) (defn-un hand-val [HandStatsT] %val) (defn-un hand-bid [HandStatsT] %bid) (defn-un hand-type-val [HandStatsT] (type-val %type)) (defn parse-line [line jokers?] (let [[cardsstr bidstr] (.split (.trim line) lib/rx_whitespace) cards (lib/strsplit cardsstr "") type (get-type cards jokers?) val (get-val cards jokers?) bid (lib/parseInt bidstr)] (mk HandStatsT (%= [type val bid])))) (defn sort-hands [hands] (let [by-type-val (+/groupBy hand-type-val hands)] (<- (+/bind (+/Vec Kind1 Kind2 TwoPair Kind3 FullHouse Kind4 Kind5)) (fn [_anon%1_22] (+/sort-by hand-val (+/or (+/Vec) (+/at by-type-val (type-val _anon%1_22)))))))) (defn get-total-winnings [input jokers?] (->> (lib/strsplit input "\n") (+/filter (fn [_anon%1_23] (not (+/is "" (.trim _anon%1_23))))) (+/fmap (fn [_anon%1_24] (parse-line _anon%1_24 jokers?))) (sort-hands) (+/reduce (fn [_anon%1_25 _anon%2_27 _anon%3_26] (+ _anon%1_25 (* (+ 1 _anon%3_26) (hand-bid _anon%2_27)))) 0))) (defn part1 [input] (get-total-winnings input false)) (defn part2 [input] (get-total-winnings input true))], :preprocessing nil}}