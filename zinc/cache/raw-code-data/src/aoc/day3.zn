{:merge-state {:defreferred nil, :refer-macros {"/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" "+"}, :name-alias nil, :placeholders nil, :get-dep-path {"lib" "/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn", "+" "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn"}, :get-as-alias {"/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn" "lib", "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" "+"}, :exporting nil, :runtime-deps {"/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn" true, "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" true}}, :res {:code [(require ' ["./lib.mjs" :as lib]) (require ' ["./../+.mjs" :as + :refer-macros true]) (def* SchemaNumberT [value part-number?]) (defn-mk (SchemaNumber [value] SchemaNumberT) (%value value) (%part-number? false)) (defn-un value [SchemaNumberT] %value) (defn-un part-number? [SchemaNumberT] %part-number?) (defn accept-part-number [schema-number] (mk SchemaNumberT (%value (value schema-number)) (%part-number? true))) (def+ TokenT (Digit [d]) (Symbol [s]) (Dot)) (defn-mk (Digit [d] TokenT) (%= [d])) (defn-mk (Symbol [s] TokenT) (%= [s])) (def Dot (mk (Dot of TokenT))) (defn classify [c] (<<- (if (+/is c ".") Dot) (let [d (lib/parseInt c)]) (if (and (>= d 0) (< d 10)) (Digit d) (Symbol c)))) (defn put-in [v2d i j v] (let [row (+/or (+/Vec) (+/at v2d i))] (+/put row j v))) (defn process-grid [input handle-symbol-neighbors] (let [token-grid (->> (lib/strsplit input "\n") (+/fmap (fn [_anon%1_46] (+/fmap classify (lib/strsplit _anon%1_46 ""))))) schema-number-id-grid (+/fmap (fn [_anon%1_47] (+/fmap (fn [] +/None) _anon%1_47)) token-grid) schema-numbers (+/Vec) init-schema-number (fn [_anon%1_48] (<<- (when (> _anon%1_48 0)) (+/put schema-numbers (+/size schema-numbers)) (SchemaNumber _anon%1_48))) add-neighbor (fn [neighbors i j] (<<- ((fn [_anon%1_50 _anon%2_49] (+/bind _anon%2_49 _anon%1_50)) (+/at schema-number-id-grid i)) (fn [row]) ((fn [_anon%1_52 _anon%2_51] (+/bind _anon%2_51 _anon%1_52)) (+/at row j)) (fn [mschema-number-id]) ((fn [_anon%1_54 _anon%2_53] (+/bind _anon%2_53 _anon%1_54)) mschema-number-id) (fn [schema-number-id]) ((fn [_anon%1_56 _anon%2_55] (+/bind _anon%2_55 _anon%1_56)) (+/at schema-numbers schema-number-id)) (fn [schema-number]) (+/put neighbors schema-number-id schema-number)))] (<- (+/each token-grid) (fn [row i] (-> (fn-impl [acc TokenT j] (Digit (let [next (+ (* 10 acc) %d)] (<<- (when (> next 0)) (put-in schema-number-id-grid i j) (+/Just (+/size schema-numbers))) next)) (_ (do (init-schema-number acc) 0))) (+/reduce 0 row) (init-schema-number)))) (<- (+/each token-grid) (fn [row i] (<- (+/each row) (fn-impl [TokenT j] (Symbol (let [neighbors (+/Map)] (add-neighbor neighbors (+/dec i) (+/dec j)) (add-neighbor neighbors (+/dec i) (+/id j)) (add-neighbor neighbors (+/dec i) (+/inc j)) (add-neighbor neighbors (+/id i) (+/dec j)) (add-neighbor neighbors (+/id i) (+/inc j)) (add-neighbor neighbors (+/inc i) (+/dec j)) (add-neighbor neighbors (+/inc i) (+/id j)) (add-neighbor neighbors (+/inc i) (+/inc j)) (handle-symbol-neighbors neighbors schema-numbers))) (_))))) schema-numbers)) (defn part1 [input] (->> (<<- (process-grid input) (fn [neighbors schema-nums]) (+/each (fn [_anon%1_58 _anon%2_57] (+/put schema-nums _anon%2_57 (accept-part-number _anon%1_58))) neighbors)) (+/filter part-number?) (+/fmap value) (+/reduce (fn [_anon%1_59 _anon%2_60] (+ _anon%1_59 _anon%2_60)) 0))) (defn part2 [input] (let [sum-ref (aref 0)] (<<- (process-grid input) (fn [neighbors]) (when (+/is 2 (+/size neighbors))) (a= sum-ref) (+ (aget sum-ref "r")) (+/reduce (fn [_anon%1_61 _anon%2_62] (* _anon%1_61 (value _anon%2_62))) 1 neighbors)) (aget sum-ref "r")))], :preprocessing nil}}