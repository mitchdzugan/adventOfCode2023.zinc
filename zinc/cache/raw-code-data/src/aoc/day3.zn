{:merge-state {:defreferred nil, :refer-macros {"/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" "+"}, :name-alias nil, :placeholders nil, :get-dep-path {"lib" "/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn", "+" "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn"}, :get-as-alias {"/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn" "lib", "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" "+"}, :exporting nil, :runtime-deps {"/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn" true, "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" true}}, :res {:code [(require ' ["./lib.mjs" :as lib]) (require ' ["./../+.mjs" :as + :refer-macros true]) (def* SchemaNumberT [value part-number?]) (defn-mk (SchemaNumber [value] SchemaNumberT) (%value value) (%part-number? false)) (defn-un value [SchemaNumberT] %value) (defn-un part-number? [SchemaNumberT] %part-number?) (defn accept-part-number [schema-number] (mk SchemaNumberT (%value (value schema-number)) (%part-number? true))) (def+ TokenT (Digit [d]) (Symbol [s]) (Dot)) (defn-mk (Digit [d] TokenT) (%= [d])) (defn-mk (Symbol [s] TokenT) (%= [s])) (def Dot (mk (Dot of TokenT))) (defn classify [c] (<<- (if (+/is c ".") Dot) (let [d (lib/parseInt c)]) (if (and (>= d 0) (< d 10)) (Digit d) (Symbol c)))) (defn put-in [v2d i j v] (let [row (+/or (+/Vec) (+/at v2d i))] (+/put row j v))) (defn process-grid [input handle-symbol-neighbors] (let [token-grid (->> (lib/strsplit input "\n") (+/fmap (fn [_anon%1_35] (+/fmap classify (lib/strsplit _anon%1_35 ""))))) schema-number-id-grid (+/fmap (fn [_anon%1_36] (+/fmap (fn [] +/None) _anon%1_36)) token-grid) schema-numbers (+/Vec) init-schema-number (fn [_anon%1_37] (<<- (when (> _anon%1_37 0)) (+/put schema-numbers (+/size schema-numbers)) (SchemaNumber _anon%1_37))) add-neighbor (fn [neighbors i j] (<<- ((fn [_anon%1_39 _anon%2_38] (+/bind _anon%2_38 _anon%1_39)) (+/at schema-number-id-grid i)) (fn [row]) ((fn [_anon%1_41 _anon%2_40] (+/bind _anon%2_40 _anon%1_41)) (+/at row j)) (fn [mschema-number-id]) ((fn [_anon%1_43 _anon%2_42] (+/bind _anon%2_42 _anon%1_43)) mschema-number-id) (fn [schema-number-id]) ((fn [_anon%1_45 _anon%2_44] (+/bind _anon%2_44 _anon%1_45)) (+/at schema-numbers schema-number-id)) (fn [schema-number]) (+/put neighbors schema-number-id schema-number)))] (<- (+/each token-grid) (fn [row i] (-> (fn-impl [acc TokenT j] (Digit (let [next (+ (* 10 acc) %d)] (<<- (when (> next 0)) (put-in schema-number-id-grid i j) (+/Just (+/size schema-numbers))) next)) (_ (do (init-schema-number acc) 0))) (+/reduce 0 row) (init-schema-number)))) (<- (+/each token-grid) (fn [row i] (<- (+/each row) (fn-impl [TokenT j] (Symbol (let [neighbors (+/Map)] (add-neighbor neighbors (+/dec i) (+/dec j)) (add-neighbor neighbors (+/dec i) (+/id j)) (add-neighbor neighbors (+/dec i) (+/inc j)) (add-neighbor neighbors (+/id i) (+/dec j)) (add-neighbor neighbors (+/id i) (+/inc j)) (add-neighbor neighbors (+/inc i) (+/dec j)) (add-neighbor neighbors (+/inc i) (+/id j)) (add-neighbor neighbors (+/inc i) (+/inc j)) (handle-symbol-neighbors neighbors schema-numbers))) (_))))) schema-numbers)) (defn part1 [input] (->> (<<- (process-grid input) (fn [neighbors schema-nums]) (+/each (fn [_anon%1_47 _anon%2_46] (+/put schema-nums _anon%2_46 (accept-part-number _anon%1_47))) neighbors)) (+/filter part-number?) (+/fmap value) (+/reduce (fn [_anon%1_48 _anon%2_49] (+ _anon%1_48 _anon%2_49)) 0))) (defn part2 [input] (let [sum-ref (aref 0)] (<<- (process-grid input) (fn [neighbors]) (when (+/is 2 (+/size neighbors))) (a= sum-ref) (+ (aget sum-ref "r")) (+/reduce (fn [_anon%1_50 _anon%2_51] (* _anon%1_50 (value _anon%2_51))) 1 neighbors)) (aget sum-ref "r")))], :preprocessing nil}}