{:merge-state {:defreferred nil, :refer-macros {"/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" "+"}, :name-alias nil, :placeholders nil, :get-dep-path {"lib" "/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn", "+" "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn"}, :get-as-alias {"/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn" "lib", "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" "+"}, :exporting nil, :runtime-deps {"/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn" true, "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" true}}, :res {:code [(require ' ["./lib.mjs" :as lib]) (require ' ["./../+.mjs" :as + :refer-macros true]) (def* SchemaNumberT [value part-number?]) (defn-mk (SchemaNumber [value] SchemaNumberT) (%value value) (%part-number? false)) (defn-un value [SchemaNumberT] %value) (defn-un part-number? [SchemaNumberT] %part-number?) (defn accept-part-number [schema-number] (mk SchemaNumberT (%value (value schema-number)) (%part-number? true))) (def+ TokenT (Digit [d]) (Symbol [s]) (Dot)) (defn-mk (Digit [d] TokenT) (%= [d])) (defn-mk (Symbol [s] TokenT) (%= [s])) (def Dot (mk (Dot of TokenT))) (defn classify [c] (if (+/is c ".") Dot (let [d (js/parseInt c 10)] (if (and (>= d 0) (< d 10)) (Digit d) (Symbol c))))) (defn put-in [v2d i j v] (let [row (+/or (+/Vec) (+/at v2d i))] (+/put row j v))) (defn process-grid [input handle-symbol-neighbors] (let [token-grid (->> (lib/strsplit input "\n") (+/fmap (fn [_anon%1_15] (+/fmap classify (lib/strsplit _anon%1_15 ""))))) schema-number-id-grid (+/fmap (fn [_anon%1_16] (+/fmap (fn [] +/None) _anon%1_16)) token-grid) schema-numbers (+/Vec) add-neighbor (fn [neighbors i j] (<<- ((fn [_anon%1_18 _anon%2_17] (+/bind _anon%2_17 _anon%1_18)) (+/at schema-number-id-grid i)) (fn [row]) ((fn [_anon%1_20 _anon%2_19] (+/bind _anon%2_19 _anon%1_20)) (+/at row j)) (fn [mschema-number-id]) ((fn [_anon%1_22 _anon%2_21] (+/bind _anon%2_21 _anon%1_22)) mschema-number-id) (fn [schema-number-id]) ((fn [_anon%1_24 _anon%2_23] (+/bind _anon%2_23 _anon%1_24)) (+/at schema-numbers schema-number-id)) (fn [schema-number]) (+/put neighbors schema-number-id schema-number))) init-schema-number (fn [_anon%1_25] (when (> _anon%1_25 0) (+/put schema-numbers (+/size schema-numbers) (SchemaNumber _anon%1_25))))] (<- (+/each token-grid) (fn [row i] (let [ending (<- (+/reduce 0 row) (fn-impl [acc TokenT j] (Digit (let [next (+ (* 10 acc) %d)] (<<- (when (> next 0)) (put-in schema-number-id-grid i j) (+/Just (+/size schema-numbers))) next)) (_ (do (init-schema-number acc) 0))))] (init-schema-number ending)))) (<- (+/each token-grid) (fn [row i] (<- (+/each row) (fn-impl [TokenT j] (Symbol (let [neighbors (+/Map)] (add-neighbor neighbors (+/dec i) (+/dec j)) (add-neighbor neighbors (+/dec i) (+/id j)) (add-neighbor neighbors (+/dec i) (+/inc j)) (add-neighbor neighbors (+/id i) (+/dec j)) (add-neighbor neighbors (+/id i) (+/inc j)) (add-neighbor neighbors (+/inc i) (+/dec j)) (add-neighbor neighbors (+/inc i) (+/id j)) (add-neighbor neighbors (+/inc i) (+/inc j)) (handle-symbol-neighbors neighbors schema-numbers))) (_ nil))))) schema-numbers)) (defn part1 [input] (->> (<<- (process-grid input) (fn [neighbors schema-nums]) (+/each (fn [_anon%1_27 _anon%2_26] (+/put schema-nums _anon%2_26 (accept-part-number _anon%1_27))) neighbors)) (+/filter part-number?) (+/fmap value) (+/reduce (fn [_anon%1_28 _anon%2_29] (+ _anon%1_28 _anon%2_29)) 0))) (defn part2 [input] (let [gear-ratio-sum-ref [0] get-gear-ratio-sum (fn [] (aget gear-ratio-sum-ref 0)) add-gear-ratio (fn [_anon%1_30] (aset gear-ratio-sum-ref 0 (+ (get-gear-ratio-sum) _anon%1_30)))] (<<- (process-grid input) (fn [neighbors]) (when (+/is 2 (+/size neighbors))) (add-gear-ratio (+/reduce (fn [_anon%1_31 _anon%2_32] (* _anon%1_31 (value _anon%2_32))) 1 neighbors))) (get-gear-ratio-sum)))], :preprocessing nil}}