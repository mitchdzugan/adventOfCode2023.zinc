{:merge-state {:defreferred nil, :refer-macros {"/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" "+"}, :name-alias nil, :placeholders nil, :get-dep-path {"lib" "/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn", "+" "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn"}, :get-as-alias {"/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn" "lib", "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" "+"}, :exporting nil, :runtime-deps {"/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn" true, "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" true}}, :res {:code [(require ' ["./lib.mjs" :as lib]) (require ' ["./../+.mjs" :as + :refer-macros true]) (def* SchemaNumberT [value part-number?]) (defn-mk (SchemaNumber [value] SchemaNumberT) (%value value) (%part-number? false)) (defn-un value [SchemaNumberT] %value) (defn-un part-number? [SchemaNumberT] %part-number?) (defn accept-part-number [schema-number] (mk SchemaNumberT (%value (value schema-number)) (%part-number? true))) (def+ TokenT (Digit [d]) (Symbol [s]) (Dot)) (defn-mk (Digit [d] TokenT) (%= [d])) (defn-mk (Symbol [s] TokenT) (%= [s])) (def Dot (mk (Dot of TokenT))) (defn classify [c] (<<- (if (+/is c ".") Dot) (let [d (js/parseInt c 10)]) (if (and (>= d 0) (< d 10)) (Digit d) (Symbol c)))) (defn put-in [v2d i j v] (let [row (+/or (+/Vec) (+/at v2d i))] (+/put row j v))) (defn process-grid [input handle-symbol-neighbors] (let [token-grid (->> (lib/strsplit input "\n") (+/fmap (fn [_anon%1_15] (+/fmap classify (lib/strsplit _anon%1_15 ""))))) schema-number-id-grid (+/fmap (fn [_anon%1_16] (+/fmap (fn [] +/None) _anon%1_16)) token-grid) schema-numbers (+/Vec) init-schema-number (fn [_anon%1_17] (<<- (when (> _anon%1_17 0)) (+/put schema-numbers (+/size schema-numbers)) (SchemaNumber _anon%1_17))) add-neighbor (fn [neighbors i j] (<<- ((fn [_anon%1_19 _anon%2_18] (+/bind _anon%2_18 _anon%1_19)) (+/at schema-number-id-grid i)) (fn [row]) ((fn [_anon%1_21 _anon%2_20] (+/bind _anon%2_20 _anon%1_21)) (+/at row j)) (fn [mschema-number-id]) ((fn [_anon%1_23 _anon%2_22] (+/bind _anon%2_22 _anon%1_23)) mschema-number-id) (fn [schema-number-id]) ((fn [_anon%1_25 _anon%2_24] (+/bind _anon%2_24 _anon%1_25)) (+/at schema-numbers schema-number-id)) (fn [schema-number]) (+/put neighbors schema-number-id schema-number)))] (<- (+/each token-grid) (fn [row i] (-> (fn-impl [acc TokenT j] (Digit (let [next (+ (* 10 acc) %d)] (<<- (when (> next 0)) (put-in schema-number-id-grid i j) (+/Just (+/size schema-numbers))) next)) (_ (do (init-schema-number acc) 0))) (+/reduce 0 row) (init-schema-number)))) (<- (+/each token-grid) (fn [row i] (<- (+/each row) (fn-impl [TokenT j] (Symbol (let [neighbors (+/Map)] (add-neighbor neighbors (+/dec i) (+/dec j)) (add-neighbor neighbors (+/dec i) (+/id j)) (add-neighbor neighbors (+/dec i) (+/inc j)) (add-neighbor neighbors (+/id i) (+/dec j)) (add-neighbor neighbors (+/id i) (+/inc j)) (add-neighbor neighbors (+/inc i) (+/dec j)) (add-neighbor neighbors (+/inc i) (+/id j)) (add-neighbor neighbors (+/inc i) (+/inc j)) (handle-symbol-neighbors neighbors schema-numbers))) (_))))) schema-numbers)) (defn part1 [input] (->> (<<- (process-grid input) (fn [neighbors schema-nums]) (+/each (fn [_anon%1_27 _anon%2_26] (+/put schema-nums _anon%2_26 (accept-part-number _anon%1_27))) neighbors)) (+/filter part-number?) (+/fmap value) (+/reduce (fn [_anon%1_28 _anon%2_29] (+ _anon%1_28 _anon%2_29)) 0))) (defn part2 [input] (let [sum-ref (aref 0)] (<<- (process-grid input) (fn [neighbors]) (when (+/is 2 (+/size neighbors))) (a= sum-ref) (+ (aget sum-ref "r")) (+/reduce (fn [_anon%1_30 _anon%2_31] (* _anon%1_30 (value _anon%2_31))) 1 neighbors)) (aget sum-ref "r")))], :preprocessing nil}}