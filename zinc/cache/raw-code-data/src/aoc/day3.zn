{:merge-state {:defreferred nil, :refer-macros {"/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" "+"}, :name-alias nil, :placeholders nil, :get-dep-path {"lib" "/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn", "+" "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn"}, :get-as-alias {"/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn" "lib", "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" "+"}, :exporting nil, :runtime-deps {"/home/mitch/Projects/adventOfCode2023.zinc/src/aoc/lib.zn" true, "/home/mitch/Projects/adventOfCode2023.zinc/src/+.zn" true}}, :res {:code [(require ' ["./lib.mjs" :as lib]) (require ' ["./../+.mjs" :as + :refer-macros true]) (def* SchemaNumberT [value part-number?]) (defn-mk (SchemaNumber [value] SchemaNumberT) (%value value) (%part-number? false)) (defn-un value [SchemaNumberT] %value) (defn-un part-number? [SchemaNumberT] %part-number?) (defn accept-part-number [schema-number] (mk SchemaNumberT (%value (value schema-number)) (%part-number? true))) (def+ TokenT (Digit [d]) (Symbol [s]) (Dot)) (defn-mk (Digit [d] TokenT) (%= [d])) (defn-mk (Symbol [s] TokenT) (%= [s])) (def Dot (mk (Dot of TokenT))) (defn classify [c] (if (+/is c ".") Dot (let [d (js/parseInt c 10)] (if (and (>= d 0) (< d 10)) (Digit d) (Symbol c))))) (defn put-in [v2d i j v] (let [row (+/or (+/Vec) (+/at v2d i))] (+/put row j v))) (defn process-grid [input handle-symbol-neighbors] (let [token-grid (->> (lib/strsplit input "\n") (+/fmap (fn [_anon%1_1] (+/fmap classify (lib/strsplit _anon%1_1 ""))))) schema-number-id-grid (+/fmap (fn [_anon%1_2] (+/fmap (fn [] +/None) _anon%1_2)) token-grid) schema-numbers (+/Vec) add-neighbor (fn [neighbors i j] (<<- ((fn [_anon%1_4 _anon%2_3] (+/bind _anon%2_3 _anon%1_4)) (+/at schema-number-id-grid i)) (fn [row]) ((fn [_anon%1_6 _anon%2_5] (+/bind _anon%2_5 _anon%1_6)) (+/at row j)) (fn [mschema-number-id]) ((fn [_anon%1_8 _anon%2_7] (+/bind _anon%2_7 _anon%1_8)) mschema-number-id) (fn [schema-number-id]) ((fn [_anon%1_10 _anon%2_9] (+/bind _anon%2_9 _anon%1_10)) (+/at schema-numbers schema-number-id)) (fn [schema-number]) (+/put neighbors schema-number-id schema-number))) init-schema-number (fn [_anon%1_11] (when (> _anon%1_11 0) (+/put schema-numbers (+/size schema-numbers) (SchemaNumber _anon%1_11))))] (<- (+/each token-grid) (fn [row i] (let [ending (<- (+/reduce 0 row) (fn-impl [acc TokenT j] (Digit (let [next (+ (* 10 acc) %d)] (<<- (when (> next 0)) (put-in schema-number-id-grid i j) (+/Just (+/size schema-numbers))) next)) (_ (do (init-schema-number acc) 0))))] (init-schema-number ending)))) (<- (+/each token-grid) (fn [row i] (<- (+/each row) (fn-impl [TokenT j] (Symbol (let [neighbors (+/Map)] (add-neighbor neighbors (+/dec i) (+/dec j)) (add-neighbor neighbors (+/dec i) (+/id j)) (add-neighbor neighbors (+/dec i) (+/inc j)) (add-neighbor neighbors (+/id i) (+/dec j)) (add-neighbor neighbors (+/id i) (+/inc j)) (add-neighbor neighbors (+/inc i) (+/dec j)) (add-neighbor neighbors (+/inc i) (+/id j)) (add-neighbor neighbors (+/inc i) (+/inc j)) (handle-symbol-neighbors neighbors schema-numbers))) (_ nil))))) schema-numbers)) (defn part1 [input] (->> (<<- (process-grid input) (fn [neighbors schema-nums]) (+/each (fn [_anon%1_13 _anon%2_12] (+/put schema-nums _anon%2_12 (accept-part-number _anon%1_13))) neighbors)) (+/filter part-number?) (+/fmap value) (+/reduce (fn [_anon%1_14 _anon%2_15] (+ _anon%1_14 _anon%2_15)) 0))) (defn part2 [input] (let [sum-ref (aref 0)] (<<- (process-grid input) (fn [neighbors]) (when (+/is 2 (+/size neighbors))) (a= sum-ref) (+ (aget sum-ref "r")) (+/reduce (fn [_anon%1_16 _anon%2_17] (* _anon%1_16 (value _anon%2_17))) 1 neighbors)) (aget sum-ref "r")))], :preprocessing nil}}