{:merge-state {:defreferred nil, :refer-macros nil, :name-alias nil, :placeholders {"zincplaceholdern1257629527" "\n// #_(\"\nconst _dig = (o, ks) => {\n  let i = 0;\n  let res = o;\n  while (i < ks.length && res) {\n    res = res[ks[i]]\n    i++;\n  }\n  return res;\n}\nconst _bury = (o, ks, v) => {\n  let i = 0;\n  let curr = o;\n  while (i < ks.length - 1) {\n    const k = ks[i]\n    curr = curr[k] = curr[k] || {}\n    i++;\n  }\n  curr[ks[i]] = v\n}\nconst _log = (...args) => console.log(...args.map(a => a && a.P));\nconst _jlog = (...args) => console.log(...args.map(a => a && a.J));\nconst _rlog = (...args) => console.log(...args);\nconst _inc = (i) => i + 1\nconst _dec = (i) => i - 1\nconst _id = a => a\nconst _const = (a) => () => a\nconst _apply = (f, ...args) => {\n  const [last, ...rest] = args.reverse();\n  const correct = [...rest.reverse(), ...last];\n  return f.apply(null, correct);\n}\nconst _str = (...args) => args.join(\"\");\nconst _argv = (...args) => args;\nconst _is = Object.is;\nconst _isNil = v => _is(v, undefined) || _is(v, null);\nconst _null = null;\nconst _isArray = Array.isArray\nconst _isFunction = (s) => _is(typeof(s), 'function');\nconst _isStr = (s) => _is(typeof(s), 'string');\nconst _arrayFrom = (it, a1, a2) => Array.from(!(a1 || a2) ? it : (function* () {\n  const pre = _isArray(a1) ? a1 : (_isArray(a2) ? a2 : []);\n  const f = _isFunction(a1) ? a1 : (_isFunction(a2) ? a2 : _id);\n  for (const el of pre) { yield el; }\n  for (const el of it) { yield f(el); }\n})())\nconst _flatArrayFrom = (it, a1, a2) => Array.from(!(a1 || a2) ? it : (function* () {\n  const pre = _isArray(a1) ? a1 : (_isArray(a2) ? a2 : []);\n  const f = _isFunction(a1) ? a1 : (_isFunction(a2) ? a2 : _id);\n  for (const el of pre) { yield el; }\n  for (const v of it) {\n    for (const el of f(v)) { yield el; }\n  }\n})())\nconst _length = a => a.length\nconst _not = (v) => !v\nconst _partial = (f, ...initArgs) => (...restArgs) => f(...initArgs, ...restArgs)\nconst _mod = (a, b) => a % b\nconst _etc = (vs) => Array.from(function*() {\n  if (!vs.length) { return }\n  let curr = vs[0];\n  for (const next of vs.slice(1)) {\n    yield curr;\n    curr = next;\n  }\n  for (const el of curr) {\n    yield el;\n  }\n})\nconst _max = (a, b) => Math.max(a, b);\nconst _min = (a, b) => Math.min(a, b);\nconst _ceil = (a) => Math.ceil(a);\nconst _floor = (a) => Math.floor(a);\nconst _round = (a) => Math.round(a);\nconst _div = (a, b) => (a / b)\nconst _pow = (a, b) => Math.pow(a, b);\nconst _abs = (a) => Math.abs(a);\nconst _random = () => Math.random();\n// \")\n"}, :get-dep-path nil, :get-as-alias nil, :exporting nil, :runtime-deps nil}, :res {:code [(def- zincplaceholdern1257629527 :placeholder) (def id js/_id) (def const js/_const) (def apply js/_apply) (def dig js/_dig) (def bury js/_bury) (def log (or (dev-only js/_log) js/_log (fn []))) (def jlog (or (dev-only js/_jlog) js/_jlog (fn []))) (def rlog (or (dev-only js/_rlog) js/_rlog (fn []))) (def inc js/_inc) (def dec js/_dec) (def str js/_str) (def argv js/_argv) (def is js/_is) (def nil? js/_isNil) (def null js/_null) (def js-array? js/_isArray) (def js-function? js/_isFunction) (def js-str? js/_isStr) (def js-array-from js/_arrayFrom) (def js-flat-array-from js/_flatArrayFrom) (def js-length js/_length) (def not js/_not) (def partial js/_partial) (def mod js/_mod) (def MapClass js/Map) (def max js/_max) (def min js/_min) (def ceil js/_ceil) (def floor js/_floor) (def round js/_round) (def div js/_div) (def pow js/_pow) (def abs js/_abs) (def random js/_random)], :preprocessing [{:type :tokenize/collection, :brace "(", :export? false, :defname "prod?", :macro? nil, :intent "def", :children [{:type :tokenize/leaf, :token {:type :tokenize/identifier, :content "preprocess"}} {:md nil, :type :tokenize/collection, :brace "(", :mod nil, :children [{:type :tokenize/leaf, :token {:type :tokenize/identifier, :row-start 1, :col-start 1, :content "def", :special ""}, :md nil} {:type :tokenize/leaf, :token {:type :tokenize/identifier, :row-start 1, :col-start 5, :content "prod?", :special ""}, :md nil} {:md nil, :type :tokenize/collection, :brace "(", :mod nil, :children [{:type :tokenize/leaf, :token {:type :tokenize/identifier, :row-start 1, :col-start 12, :content "=", :special ""}, :md nil} {:type :tokenize/leaf, :token {:type :tokenize/string, :row-start 1, :col-start 0, :content "production", :special ""}, :md nil} {:md nil, :type :tokenize/collection, :brace "(", :mod nil, :children [{:type :tokenize/leaf, :token {:type :tokenize/identifier, :row-start 1, :col-start 2, :content "..", :special ""}, :md nil} {:type :tokenize/leaf, :token {:type :tokenize/identifier, :row-start 1, :col-start 5, :content "js/process", :special ""}, :md nil} {:type :tokenize/leaf, :token {:type :tokenize/identifier, :row-start 1, :col-start 16, :content "-env", :special ""}, :md nil} {:type :tokenize/leaf, :token {:type :tokenize/identifier, :row-start 1, :col-start 21, :content "-NODE_ENV", :special ""}, :md nil}], :open-token {:brace "(", :mod nil, :type :tokenize/collection-open, :row-start 1, :col-start 1, :content "(", :special ""}, :close-token {:brace "(", :mod nil, :type :tokenize/collection-close, :row-start 1, :col-start 30, :content ")", :special ""}}], :open-token {:brace "(", :mod nil, :type :tokenize/collection-open, :row-start 1, :col-start 11, :content "(", :special ""}, :close-token {:brace "(", :mod nil, :type :tokenize/collection-close, :row-start 1, :col-start 31, :content ")", :special ""}}], :open-token {:brace "(", :mod nil, :type :tokenize/collection-open, :row-start 1, :col-start 0, :content "(", :special ""}, :close-token {:brace "(", :mod nil, :type :tokenize/collection-close, :row-start 1, :col-start 32, :content ")", :special ""}}]} {:type :tokenize/collection, :brace "(", :export? true, :defname "dev-only", :macro? "defmacro", :intent "defmacro", :children [{:type :tokenize/leaf, :token {:type :tokenize/identifier, :content "preprocess"}} {:md nil, :type :tokenize/collection, :brace "(", :mod nil, :children [{:type :tokenize/leaf, :token {:type :tokenize/identifier, :row-start 4, :col-start 1, :content "defmacro", :special ""}, :md nil} {:type :tokenize/leaf, :token {:type :tokenize/identifier, :row-start 4, :col-start 10, :content "dev-only", :special ""}, :md nil} {:md nil, :type :tokenize/collection, :brace "[", :mod nil, :children [{:type :tokenize/leaf, :token {:type :tokenize/identifier, :row-start 4, :col-start 20, :content "v", :special ""}, :md nil}], :open-token {:brace "[", :mod nil, :type :tokenize/collection-open, :row-start 4, :col-start 19, :content "[", :special ""}, :close-token {:brace "[", :mod nil, :type :tokenize/collection-close, :row-start 4, :col-start 21, :content "]", :special ""}} {:md nil, :type :tokenize/collection, :brace "(", :mod nil, :children [{:type :tokenize/leaf, :token {:type :tokenize/identifier, :row-start 4, :col-start 24, :content "when-not", :special ""}, :md nil} {:type :tokenize/leaf, :token {:type :tokenize/identifier, :row-start 4, :col-start 33, :content "prod?", :special ""}, :md nil} {:type :tokenize/leaf, :token {:type :tokenize/identifier, :row-start 4, :col-start 39, :content "v", :special ""}, :md nil}], :open-token {:brace "(", :mod nil, :type :tokenize/collection-open, :row-start 4, :col-start 23, :content "(", :special ""}, :close-token {:brace "(", :mod nil, :type :tokenize/collection-close, :row-start 4, :col-start 40, :content ")", :special ""}}], :open-token {:brace "(", :mod nil, :type :tokenize/collection-open, :row-start 4, :col-start 0, :content "(", :special ""}, :close-token {:brace "(", :mod nil, :type :tokenize/collection-close, :row-start 4, :col-start 41, :content ")", :special ""}}]}]}}